---
tags: Network
---

1.   下面关于网络协议的说法，哪些是错误的？

     之所以叫协议栈，是因为它们像积木一样是一层层搭起来的

     TCP/IP 协议栈就是指 TCP/IP 协议

     TCP/IP 模型和 OSI 模型里的层次是一一精确对应的

     在协议栈中下层对于上层是“透明”的，上层不关心下层的传输细节

     >   A，正确，协议栈是有层次的，上层依赖下层，就像是积木。
     >   B，错误，TCP/IP 协议栈里还有其他的很多协议，比如 UDP、FTP、HTTP，TCP/IP 只是其中最著名的两个协议。
     >   C，错误，TCP/IP 是四层，OSI 是七层，无法一一精确对应，OSI 的五层、六层、七层都对应到 TCP/IP 的应用层。
     >   D，正确，协议栈分层的目的就是层次间解耦隔离。

2.   下面关于域名和 DNS 的说法，哪个是错误的？

     域名本质上是 IP 地址的替代

     域名解析必须使用 DNS 服务器

     一个域名可以解析出多个 IP 地址

     域名解析系统是一个树状、分布式的服务，叶子节点是权威 DNS 服务器

     >   A，正确，域名就是为了解决 IP 地址难记忆、难管理、难输入而出现的。
     >   B，错误，操作系统缓存、本地 HOSTS 文件也可以实现域名解析，不是必须要访问 DNS 服务器。
     >   C，正确，一个域名可以对应多个 IP 地址，实现负载均衡。
     >   D，正确，参考第 6 讲。

3.   下面关于 HTTP 报文的说法，哪些是错误的？

     HTTP 报文是纯文本格式的，所以不能传输二进制数据

     HTTP 报文使用空行分隔 header 和 body，所以 header 里一定不能有空行

     HTTP 的头字段是大小写敏感的，要区分大小写

     不能随便自定义头字段，否则客户端或者服务器会因为无法识别而发生内部错误

     >   A，错误，HTTP/1.1 使用 ASCII 码标记报文头，但报文传输的数据没有限制。
     >   B，正确，如果有空行，那么空行后的数据就会被认为是 body，导致 header 缺失。
     >   C，错误，HTTP 头字段不区分大小写，但大小写混合的形式会比较容易阅读。
     >   D，错误，自定义字段无法识别是正确的，但可以忽略，不会导致错误。

4.   下面关于 HTTP 请求报文的说法，哪些是错误的？

     HTTP 的请求方法可以完整地映射成数据库的 CURD 操作

     GET 方法用来获取数据，只能在 URI 里以 query 的方式传递额外的参数

     头字段 Host 的值就是 URI 里的主机名加端口号

     URI 里的 path 部分必须以“/”开头

     >   A，正确，CURD 对应 POST/GET/PUT/DELETE。
     >   B，错误，GET 方法也可以有请求体，在 body 里传递数据。
     >   C，错误，Host 字段里是主机名，但不含端口号。
     >   D，正确，path 必须有 "/"。

5.   下面关于 HTTP 响应报文的说法，哪个是正确的？

     状态行里的原因短语作用不大，很少有人用，所以可以省略

     状态码的值必须大于等于 100

     200/204 都表示服务器成功处理了客户端的请求

     如果后端服务暂时不可用，应该返回 4XX 状态码

     >   A，错误，虽然原因短语几乎没用，但协议要求必须有，不能省略。
     >   B，错误，状态码可以自定义，所以是多少都可以。
     >   C，正确，2XX 都表示成功处理了客户端的请求。
     >   D，错误，服务器出错应该返回 5XX 状态码。

6.   下面关于 HTTP 实体数据的说法，哪些是正确的？

     HTTP 头里可以不指明 body 的 MIME 类型，让服务器或者客户端去“猜”

     Accept 字段只能用于请求头

     MIME type 和 Encoding type 可以混用，同时指定实体的数据类型和编码方式

     Vary 字段是由请求头里的 Accept 和响应头里的 Content-Type 共同决定的

     >   A，正确，但指定 MIME 会更方便程序的处理。
     >   B，正确，表示客户端可以接受的数据类型。
     >   C，正确，MIME 和 Encoding 不冲突。
     >   D，错误，Vary 只能由请求头里的字段决定，与响应头无关。

7.   下面关于 HTTP 连接的说法，哪些是正确的？

     HTTP/1.1 默认总使用长连接

     长连接优化了 TCP 的握手和挥手，所以提高了效率

     长连接很有用，所以服务器应当永远与客户端保持长连接

     域名分片技术并没有解决队头阻塞问题

     >   A，正确，HTTP/1.0 默认是短连接。
     >   B，错误，HTTP 层面不能优化下层的 TCP，长连接只是均摊了握手与挥手的成本。
     >   C，错误，长连接会占用服务器资源，所以应当适时关闭空闲的长连接，或者达到一定请求数量上限时主动关闭。
     >   D，正确，队头阻塞是长连接、TCP 固有的，域名分片只是增加了并发连接数。

8.   下面关于 HTTP 重定向的说法，哪些是正确的？

     重定向跳转时必须指定 Location 字段

     重定向时可以使用绝对 URI，也可以使用相对 URI

     如果网站迁移到 HTTPS，应该使用 301 重定向

     重定向有性能损耗，应当尽量少用

     >   A，正确，没有目标，无法重定向。
     >   B，正确，站内跳转可以用相对 URI，站外跳转应该用绝对 URI。
     >   C，正确，网站迁移，是永久改变，所以要用 301 永久重定向。
     >   D，正确，重定向跳转可能会产生两次请求，网络成本高。

9.   下面关于 HTTP Cookie 的说法，哪个是错误的？

     为了克服 HTTP 无状态的缺点，所以发明了 Cookie 机制

     服务器使用 Set-Cookie 字段，一次只能设置一个 Key-Value，想要设置多个 Key-Value 就要用多个 Set-Cookie 字段

     Max-Age=0 表示 Cookie 永远有效

     Cookie 可能会导致安全隐患，所以要用 Secure 等属性来限制使用

     >   A，正确，Cookie 让 HTTP 协议有了“记忆”能力。
     >   B，正确，参见第 19 讲。
     >   C，错误，Max-Age=0 表示 Cookie 立即失效。
     >   D，正确，不设防的 Cookie 会导致信息泄漏。

10.   下面关于 HTTP 缓存的说法，哪些是错误的？

      缓存的有效期是从客户端收到缓存的时刻开始算起

      客户端必须向服务器发起“if-Modified-Since”或“If-None-Match”条件请求，获得 304 响应后才能使用缓存

      缓存代理是 CDN 的技术基础之一

      “if-Modified-Since”和“Last-modified”标记的缓存只能精确到秒级

      >   A，错误，缓存的有效期是从报文生成的时刻开始算起，即 Date 字段。
      >   B，错误，缓存可以直接用，条件请求是用来检查缓存是否有效、是否需要更新。
      >   C，正确，CDN 利用了缓存代理技术。
      >   D，正确，因为“Last-modified”使用的是秒级时间戳。

11.   下面关于加密解密的说法，哪些是正确的？

      对称算法在加密解密时都用的是同一个密钥

      非对称算法里的公钥只能用于加密，不能用于解密

      椭圆曲线算法要比 RSA 算法更安全

      混合加密系统中非对称算法解决的是密钥交换问题

      >   A，正确，加解密用一个密钥，所以叫“对称算法”。
      >   B，错误，公钥私钥都可以互相加密解密，但公钥的解密一般用来验证签名。
      >   C，错误，准确地说应该是相同的密钥长度的前提下，否则长密钥的 RSA 肯定要比短密钥的椭圆曲线安全。
      >   D，正确，参见第 24 讲。

12.   下面关于数字签名的说法，哪些是正确的？

      MD5、SHA1 的安全强度低，应当尽量少用。

      数字签名的关键是密钥的秘密性，所以只要保护好对称密钥，用对称算法也能实现数字签名

      数字证书能够防止伪造公钥，靠的就是 CA 对证书的签名

      CA 只能自己证明自己，也就是用自签名证书。

      >   题目解析
      >
      >   A，正确，MD5、SHA1 不建议用在 HTTPS/TLS 里，但其他对安全要求不高的场景还是可以使用的。
      >   B，错误，对称密钥的加解密会导致至少两个人持有密钥，所以无法验证身份。
      >   C，正确。
      >   D，错误，CA 也可以由其他 CA 来签名证明身份，只有根 CA 才需要自己证明自己。

13.   下面关于 TLS 的说法，哪些是正确的？

      HTTP 运行在 SSL/TLS 上，就成了 HTTPS

      TLS 本质上就是混合加密，用非对称算法安全地协商出对称密钥

      RSA 算法交换密钥不需要“Server Key Exchange”消息

      应当优先选用 ECDHE 算法，因为它更快更安全

      >   题目解析
      >
      >   A，正确，HTTPS=HTTP over SSL/TLS。
      >   B，正确。
      >   C，正确，RSA 交换密钥使用的是“Client Key Exchange”消息。
      >   D，正确，ECDHE 支持 False Start 和前向安全。

14.   下面关于 TLS1.3 的说法，哪些是错误的？

      TLS1.3 里禁止使用 DES、SHA1 等不安全的算法

      TLS1.3 完全握手只需要 1-RTT，用的是 False Start 技术

      TLS1.3 简化了握手，不需要三个随机数即可生成 Pre-Master

      TLS1.3 使用 Session Ticket 技术实现了 0-RTT 握手

      >   A，正确，TLS1.3 里只能使用 AES/ChaCha20/SHA-256 等算法。
      >   B，错误，TLS1.3 握手虽然也是 1-RTT，但靠的是简化算法套件和握手协商过程。
      >   C，错误，TLS1.3 仍然需要三个随机数，绝对不能省略，但可以在握手的一个消息往返里获取。
      >   D，错误，TLS1.3 使用的是 PSK，Session Ticket 是 TLS1.2 的技术。

15.   下面关于 HTTPS 迁移的说法，哪些是错误的？

      免费的证书不可靠，不应该用

      为了兼容旧系统，服务器可以配置成双证书验证

      启用“Session ID”“Session Ticket”可以优化服务器的 HTTPS 性能

      密码套件应该配置成客户端优先，加快客户端的处理速度

      >   A，错误，证书的可靠性与收费无关，与 CA 的信誉度有关。
      >   B，正确，双证书可以同时支持 RSA 和 ECDHE。
      >   C，正确，启用会话复用可以减少再次握手的时间。
      >   D，错误，客户端优先会降低服务器的安全级别，应该配置成服务端优先。

16.   下面关于 HTTP/2 的说法，哪些描述是错误的？

      HTTP/2 只支持加密的形式，即 HTTPS

      HTTP/2 是二进制的协议，所以只能传二进制数据，不能传纯文本

      HTTP/2 里允许服务器主动向客户端“推送”数据

      HTTP/2 强制压缩 header，但不强制压缩 body

      >   A，错误，HTTP/2 允许明文形式，但各大浏览器只支持加密形式。
      >   B，错误，二进制数据包含纯文本数据。
      >   C，正确，HTTP/2 可以开偶数流向客户端发数据。
      >   D，正确，HTTP/2 使用 HPack 压缩头字段，但 body 没有做要求。

17.   下面关于 HTTP/2 的说法，哪些是正确的？

      HPack 算法使用索引表、查字典的方式来压缩、解压数据

      HTTP/2 的流是并发的，一个连接里可以有很多个流同时收发数据

      HTTP/2 的流是虚拟的，由多个标识符相同的帧组成

      HTTP/2 的流不能无限创建，有一个上限，到达上限后就必须关闭连接

      >   A，正确，HPack 使用静态表和动态表。
      >   B，正确，这是 HTTP/2 的核心特性。
      >   C，正确，流只是逻辑上的概念，实际上就是帧序列。
      >   D，正确，流标识符限定了流的总数，上限是 2^30。

18.   下面关于 HTTP/3 的说法，哪些是正确的？

      HTTP/3 下层的 QUIC 协议基于 UDP，所以是不可靠的

      QUIC 内置了 TLS 协议，所以 HTTP/3 总是加密的

      HTTP/3 里的流其实就是 QUIC 里的流

      HTTP/3 使用不透明的“连接 ID”，支持“连接迁移”，可以无缝切换网络

      >   A，错误，QUIC 虽然基于 UDP，但它实现了可靠传输。
      >   B，正确，HTTP/3 没有明文形式。
      >   C，正确，HTTP/3 直接复用了 QUIC 的流，帧里不再包含流标识符。
      >   D，正确，参见第 32 讲。

19.   下面的说法中哪个是错误的？

      Nginx 高性能的关键是进程池和 IO 多路复用

      WAF 是应用级别的防火墙，可以防止 SQL 注入等攻击

      CDN 的核心技术是全局负载均衡和缓存代理，但因为 HTTP 缓存的限制，只能加速静态资源

      WebSocket 在握手时发送的其实是一个标准的 HTTP GET 请求

      >   A，正确，参见第 34 讲。
      >   B，正确，参见第 36 讲。
      >   C，错误，CDN 使用专线、边缘计算等技术也能加速动态资源。
      >   D，正确，参见第 38 讲。

20.   下面关于 HTTP 优化的说法，哪些是正确的？

      衡量服务器性能的指标主要有吞吐量、并发数和响应时间

      影响客户端性能的关键要素是网络延迟

      购买 CDN 服务是优化网站性能的有效手段

      资源合并在 HTTP/2 里会对性能优化起到反效果

      >   A，正确，参见第 39 讲。
      >   B，正确，参见第 39 讲。
      >   C，正确，CDN 是性价比最高的 HTTP 优化手段。
      >   D，正确，资源合并会降低缓存的利用率，浪费 HTTP/2 的带宽。

