---
tags: C++ DSA Palindrome
---



# KMP算法









# 动态规划解法

1.   [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/);

     ```cpp
     ```

     

2.   [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/);

     ```cpp
     ```

     

3.   [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/);

     ```cpp
     class Solution {
     public:
         int longestPalindromeSubseq(string s) {
             int n = s.size();
             int dp[n][n]; // dp[i][j]表示从i到j的最长回文子序列长度
             memset(dp, 0, sizeof(dp));
             for (int i{}; i < n; ++i) dp[i][i] = 1;
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i + 1}; j < n; ++j)
                     if (s[i] == s[j])
                         dp[i][j] = dp[i + 1][j - 1] + 2;
                     else
                         dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
             return dp[0][n - 1];
         }
     };
     ```
     
     





# 双指针解法(中心扩展)

1.   [2108. 找出数组中的第一个回文字符串](https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/);(开胃菜)

     ```cpp
     class Solution {
     public:
         string firstPalindrome(vector<string>& words) {
             auto isPalindrome = [](const string& s) {
                 int l{}, r = s.size() - 1;
                 for (; l < r; ++l, --r) 
                     if (s[l] != s[r]) return false;
                 return true;
             };
             for (auto& s : words)
                 if (isPalindrome(s))
                     return s;
             return ""s;
         }
     };
     ```

     

2.   [1616. 分割两个字符串得到回文串](https://leetcode.cn/problems/split-two-strings-to-make-palindrome/);

     ```cpp
     ```

     

3.   [1638. 统计只差一个字符的子串数目](https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/);

     ```cpp
     class Solution {
     public:
         int countSubstrings(string s, string t) {
             int ans{}, m = s.size(), n = t.size();
             for (int i{}; i < m; ++i)
                 for (int j{}; j < n; ++j) {
                     if (s[i] != t[j]) {
                         int l{}, r{};
                         while (l < i && l < j && s[i - l - 1] == t[j - l - 1]) ++l;
                         while (i + r + 1 < m && j + r + 1 < n &&
                                s[i + r + 1] == t[j + r + 1])
                             ++r;
                         ans += (l + 1) * (r + 1);
                     }
                 }
             return ans;
         }
     };
     ```

4.   [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/);

     ```cpp
     class Solution {
     public:
         int countSubstrings(string s) {
             int n = s.size(), ans{};
             for (int i{}; i < n; ++i)
                 for (int j{}; j < 2; ++j) { // 奇偶中心
                     int l{i}, r{i + j};
                     // 扩展中心
                     while (l >= 0 && r < n && s[l--] == s[r++]) ++ans;
                 }
             return ans;
         }
     };
     ```

     

5.   [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/);(上一题直接加一个判断即可)

     ```cpp
     class Solution {
     public:
         string longestPalindrome(string s) {
             int n = s.size(), ansL{}, maxLen{};
             for (int i{}; i < n; ++i)
                 for (int j{}; j < 2; ++j) { // 奇偶中心
                     int l{i}, r{i + j};
                     // 扩展中心
                     while (l >= 0 && r < n && s[l--] == s[r++])
                         if (r - l - 1 > maxLen) maxLen = r - l - 1, ansL = l + 1;
                 }
             return s.substr(ansL, maxLen);
         }
     };
     ```

6.   [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/);双指针最快

     ```cpp
     class Solution {
     public:
         bool isSubsequence(string s, string t) {
             int m = s.size(), n = t.size(), i{}, j{};
             while (i < m && j < n) {
                 if (s[i] == t[j]) ++i;
                 ++j;
             }
             return i == m;
         }
     };
     // 
     class Solution {
     public:
         bool isSubsequence(string s, string t) {
             int m = s.size(), n = t.size(), i{}, j{};
             while (i < m && j < n) {
                 while (i < m && j < n && s[i] == t[j]) ++i, ++j;
                 ++j;
             }
             return i == m;
         }
     };
     ```

     







# 回溯类

1.   [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/);

     ```cpp
     class Solution {
     public:
         vector<vector<string>> partition(string s) {
             auto isPalindorme = [&](int l, int r) {
                 for (; l < r; ++l, --r)
                     if (s[l] != s[r]) return false;
                 return true;
             };
             int n = s.size();
             vector<vector<string>> ans{};
             vector<string> path{};
             function<void(int)> f = [&](int start) {
                 if (start == n) {
                     ans.emplace_back(path);
                     return;
                 }
                 for (int i{start}; i < n; ++i) {
                     if (!isPalindorme(start, i)) continue;
                     path.emplace_back(s.substr(start, i - start + 1));
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```
     
2.   



