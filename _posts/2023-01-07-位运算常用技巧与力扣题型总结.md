---
tags: Mathematics DSA C++ Python
---



# 写在前面

最近刷LeetCode, 发现很多双百题解中用到的都是位运算技巧, 下面来总结一下位运算的常用技巧. 一开始参考了知乎的一篇回答, 里面推荐一本书叫做*算法心得*, 英文原版为*Hackers Delight*, 听这个名字就知道是一些hack技巧, 有机会一定要研读一下. 下面的代码用C++或者Python给出. 



# 预备知识

首先给出一些预备知识, 包括如何进制转换等.

## 任意进制到十进制

```python
def x2dec(x: str, k: int) -> int:
    """k-base number x to decimal number"""
    ans = 0
    for i in range(n := len(x)):
        ans += int(x[n - 1 - i]) * k**i
    return ans
```



```cpp
int x2dec(string x, int k) {
    int ans{}, n = x.size();
    for (int i{}; i < n; ++i)
        ans += (static_cast<int>(x[n - 1 - i]) - 48) * pow(k, i);//with cmath
    return ans;
}
```



## 十进制到任意进制

```python
def dec2x(x: int, k: int) -> str:
    """decimal number x to k-base system number"""
    ans = ''
    while x:
        x, r = divmod(x, k)
        ans = str(r) + ans
    return ans
```



```cpp
string dec2x(int x, int k) {
    string ans{};
    while (x) {
        ans = to_string(x % k) + ans;
        x /= k;
    }
    return ans;
}
```



# 位运算操作符

这里以C++为例. 

>   有的语言可能有一些区别, 例如JavaScript中的左移位还分为有符号和无符号的情况, 包括了三种移位操作. 

| 运算名称 | 符号 |           运算规则           |
| :------: | :--: | :--------------------------: |
|    与    | `&`  | `0&0=0  0&1=0  1&0=0  1&1=1` |
|    或    | `|`  | `0|0=0  0|1=1  1|0=1  1|1=1` |
|    非    | `~`  |         `~0=1 ~1=0`          |
|   异或   | `^`  | `0^0=0  0^1=1  1^0=1  1^1=0` |
|  左移位  | `<<` |       `0001<<1 = 0010`       |
|  右移位  | `>>` |       `1000>>1 = 0100`       |



## 优先级

这里要注意一点, **位运算符的优先级要低于比较运算符**, 所以位运算最好带上括号, 否则会有意想不到的问题. 下面的运算符优先级表是cppreference[^1]中的. 

![截屏2022-12-09 10.50.44](https://s2.loli.net/2022/12/09/hZxOY1lkN4WmjsQ.jpg)



一个很坑的点就是C语言用与运算判断数字的奇偶性, 奇数的话当然没问题:

```c
#include <stdio.h>

int main(int argc, char const *argv[]) {
    int n = 11;
    if (n & 1) printf("n is odd\n");
    return 0;
}
```

但是当你加上了一个`==0`, 情况就发生了变化:

```c
#include <stdio.h>

int main(int argc, char const *argv[]) {
    int n = 10;
    if (n & 1 == 0) printf("n is even\n");
    return 0;
}
```

10难道不是偶数了? 问题就出在了`==`和`&`的优先级上面, `==`优先级高, 所以会先计算`1==0`, 得到了`false`之后隐式类型转换为`0`, 这时候`10&0`肯定就是0了, 才会出现10不是偶数这种错误. 

>   写位运算一定要注意判断语句, 总之就是, 有位运算最好还是都带上括号, 保险. 





# 异或

-   `a^a=0`;
-   `a^0=0^a=a`;
-   `t=x^y`$\iff$`x^t=x^x^y=y`$\iff$`y^t=y^x^y=y^y^x=x`;
-   

## 奇偶数的性质

1.   加一减一:
     -   `x`为奇数时: `x-1=x^1`;
     -   `x`为偶数时: `x+1=x^1`;

## 交换两个数

交换两个数应该是最经典也是最基础的一种算法了, 下面是异或实现, 不使用临时变量:

```cpp
void swap(int a, int b){
    a ^= b; // 此时a=a^b,b=b
    b ^= a; // 此时a=a^b,b=b^a^b=a
    a ^= b; // 此时a=a^b^a=b,b=a
}
```

或者利用C/C++的连等写法:

```cpp
void swap(int &a, int &b) { a ^= b ^= a ^= b; }
```

比较骚的方法. 

## 找不同(数或字符串)

利用异或运算的性质, 遍历一次数组就可以找到结果了(如果是有序数组还可以通过二分来做降低时间复杂度)

例如对于力扣的[面试题 17.04. 消失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number-lcci/);

用位运算来做简直完美:(求和也可以)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int ans{};
        for (int num:nums)ans^=num;
        for(int i=0;i<=nums.size();++i)ans^=i;
        return ans;
    }
};
```

类似还有[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/);

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans{};
        for(int num:nums)ans^=num;
        return ans;
    }
};
```



# 与

## 判断奇偶

```python
isOdd = lambda n: (n&1)==1 #Python的括号可以不加, 但是要注意优先级
```



## 指定位计数

对于一个二进制串`1011001`(89), 其中含有的`1`的个数有多少呢? 一个直观的思路当然是遍历取出, 直接模拟, 例如像下面这样:

```python
def calcbit1(n):
    ans = 0
    while n:
        tmp = n & 1  # 取最末位
        ans += tmp
        n >>= 1  # 进位
    return ans
```

一些常用的技巧

```js
x & (x - 1) //清除最右边的1
x & -x //得到最右边的1(lsb, 最低有效位)

```

## 判断2的幂(数的二进制表示是否仅有一位)

```python
(n&(n-1))==0
```

对于一个二进制数, 例如`10`, 其二进制表示为`1010`, `10-1=9`的二进制表示为`1001`, 两者做与运算得到`1000`即`=8!=0`, 但是对于`0100`(4), 其与`3`(`0011`)做与运算就是`0`, 这是因为对任意一个数`x`, 其减去`1`之后得到的二进制数需要从二进制表示的`从低位到高位`中最近的一个`1`借位, 使该借位的`1`后面的所有`0`都变成`1`, 那么如果这个数`x`仅有一个位`1`的话, 就可得出`x&x-1=0`了, 反之, 如果数`x`的二进制表示中不只有一个`1`, 那么减一操作只会借走最低位的`1`, 而其他剩下的`1`就不会变成`0`, 导致与运算之后结果不为`0`了.

而一个数字是不是`2`的幂, 只需要看其二进制表示中是不是只有一个位为`1`, 于是就可以通过`x&x-1==0`来判断了.



```python
(n&(-n))==n
```

同样地, 我们来分析



## 找出某数的某一个二进制位

```python
# Python Version
# 获取 a 的第 b 位，最低位编号为 0
def getBit(a, b):
    return (a >> b) & 1
```

```cpp
// 获取 a 的第 b 位，最低位编号为 0
int getBit(int a, int b){
 	return (a >> b) & 1;   
}
```

这个和下面的一个技巧都是数位DP中比较常用的设置mask掩码的技巧, 希望大家熟练掌握. 

# 或

## 某一位设置为1

>   在数位DP, 状态压缩中常用

```python
# Python Version
# 将 a 的第 b 位设置为 1 ，最低位编号为 0
def setBit(a, b):
    return a | (1 << b)
```

[1832. 判断句子是否为全字母句 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-the-sentence-is-pangram/);

这个题当然可以直接哈希完事, 但是需要消耗空间, 这里就通过一个`26`位的带符号整数来完成. 







# 综合运用

## 用位运算模拟两数相加(异或)

[剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/);

这里要用到异或运算的知识, 以及整数补码和溢出情况的分析. 

```cpp
class Solution {
public:
    int add(int a, int b) {
        if (b==0) return a;
        if (a==0) return b;
        int carry{},ans{};
        while (b){
            carry=(unsigned)(a&b)<<1;
            a^=b;//a加到不进位位置
            b=carry;
        }
        return a;
    }
};
```

## 只出现一次的数字系列

1.   


# ref

[^1]:[C++ Operator Precedence - cppreference.com](https://en.cppreference.com/w/cpp/language/operator_precedence);
