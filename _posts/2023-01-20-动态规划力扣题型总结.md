---
tags: DSA LeetCode C++
---





# 入门

>   [Overlapping Subproblems Property in Dynamic Programming | DP-1 - GeeksforGeeks](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/);

1.   [剑指 Offer 10- I. 斐波那契数列 - 力扣（LeetCode）](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/);

     ```cpp
     class Solution {
     public:
         int fib(int n) {
             const int MOD = 1e9 + 7;
             int a{}, b{1};
             for (int i{}; i < n; ++i) tie(a, b) = pair(b, a % MOD + b % MOD);
             return a % MOD;
         }
     };
     ```

2.   [509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/);

     ```cpp
     vector<int> a(31, -1);
     class Solution {
     public:
         int fib(int n) {
             if (a[n] == -1) {
                 if (n <= 1)
                     a[n] = n;
                 else
                     a[n] = fib(n - 1) + fib(n - 2);
             }
             return a[n];
         }
     };
     // 滚动数组优化
     class Solution {
     public:
         int fib(int n) {
             int a{}, b{1};
             for (int i{}; i < n; ++i) {
                 int tmp = b;
                 b += a;
                 a = tmp;
             }
             return a;
         }
     };
     ```
     
     



# 路径问题

1.   [62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/);(经典的二维DP问题)

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             vector<vector<int>> dp(m, vector<int>(n));
             for (int i{}; i < n; ++i) dp[0][i] = 1;
             for (int j{1}; j < m; ++j) dp[j][0] = 1;
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
             return dp[m - 1][n - 1];
         }
     };
     ```

     滚动数组优化:

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             vector<int> dp(n, 1);
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j) dp[j] += dp[j - 1];
             return dp[n - 1];
         }
     };
     ```

     组合数学公式方法也可以:(注意这里`ans=ans*...`是必须的, 因为如果写成`ans*=...`会导致除法舍入)

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             long ans{1};
             for (int i{}; i < m - 1; ++i) ans = ans * (n + i) / (i + 1);
             return ans;
         }
     };
     ```

     

2.   [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/);

     ```cpp
     class Solution {
     public:
         int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
             int m = obstacleGrid.size(), n = obstacleGrid[0].size();
             if (obstacleGrid[0][0]) return 0; // 注意初始值为障碍物, 后面不需要考虑
     
             vector<vector<int>> dp(m, vector<int>(n));
             int i{}, j{1};
             for (; i < n && obstacleGrid[0][i] != 1; ++i) dp[0][i] = 1;
             for (; j < m && obstacleGrid[j][0] != 1; ++j) dp[j][0] = 1;
             for (i = 1; i < m; ++i)
                 for (j = 1; j < n; ++j)
                     if (obstacleGrid[i][j] == 0)
                         dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
             return dp[m - 1][n - 1];
         }
     };
     ```

     同样可以滚动数组优化:(有点技巧, 参考了官方题解)

     ```cpp
     class Solution {
     public:
         int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
             int m = obstacleGrid.size(), n = obstacleGrid[0].size();
             vector<int> dp(n);
             dp[0] = obstacleGrid[0][0] != 1;
             for (int i{}; i < m; ++i)
                 for (int j{}; j < n; ++j) {
                     if (obstacleGrid[i][j]) {
                         dp[j] = 0;
                         continue;
                     }
                     if (j && obstacleGrid[i][j - 1] == 0) dp[j] += dp[j - 1];
                 }
             return dp[n - 1];
         }
     };
     ```

     

3.   [64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/);

4.   [980. 不同路径 III - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-iii/);

5.   





# 序列/子序列/子数组

## 子序列

1.   [674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/);

     DP做法:

     ```cpp
     class Solution {
     public:
         int findLengthOfLCIS(vector<int>& nums) {
             int n = nums.size();
             vector<int> dp(n, 1);
             dp[0] = 1;
             for (int i{1}; i < n; ++i)
                 if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
     
             return *max_element(dp.begin(), dp.end());
         }
     };
     ```

     贪心也能做:(最优方法, 空间复杂度$O(1)$)

     ```cpp
     class Solution {
     public:
         int findLengthOfLCIS(vector<int>& nums) {
             int pre = INT_MIN, ans{}, tmp{};
             for (auto num : nums) {
                 if (num > pre)
                     tmp++;
                 else
                     ans = max(ans, tmp), tmp = 1;
                 pre = num;
             }
             return max(ans, tmp);
         }
     };
     ```

     

2.   [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/);(贪心也可以做)

     ```cpp
     class Solution {
     public:
         int lengthOfLIS(vector<int>& nums) {
             int n = nums.size();
             vector<int> dp(n, 1);
             for (int i{1}; i < n; ++i)
                 for (int j{}; j < i; ++j)
                     if (nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1);
             return *max_element(dp.begin(), dp.end());
         }
     };
     ```
     
3.   [2407. 最长递增子序列 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence-ii/);

4.   [1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/);[剑指 Offer II 095. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/qJnOS7/);

     ```cpp
     ```

     



## 序列

1.   [128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/);

     ```cpp
     ```

     

2.   [1691. 堆叠长方体的最大高度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/);

5.   [354. 俄罗斯套娃信封问题 - 力扣（LeetCode）](https://leetcode.cn/problems/russian-doll-envelopes/);

6.   





## 子数组

1.   [718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/);

     ```cpp
     ```

     

2.   

3.   















# 数位DP(难, 本质上是记忆化深搜)

>   [数位 DP 通用模板，附题单（Python/Java/C++/Go） - 不含连续1的非负整数 - 力扣（LeetCode）](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/solution/by-endlesscheng-1egu/);

1.   [600. 不含连续1的非负整数 - 力扣（LeetCode）](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/);
2.   [233. 数字 1 的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-digit-one/);
3.   [面试题 17.06. 2出现的次数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-2s-in-range-lcci/);
4.   [902. 最大为 N 的数字组合 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/);
5.   [1012. 至少有 1 位重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-with-repeated-digits/);
6.   [1397. 找到所有好字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-good-strings/);
7.   

