---
tags: DSA LeetCode C++
---





# 入门

>   [Overlapping Subproblems Property in Dynamic Programming | DP-1 - GeeksforGeeks](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/);

1.   [剑指 Offer 10- I. 斐波那契数列 - 力扣（LeetCode）](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/);

     ```cpp
     class Solution {
     public:
         int fib(int n) {
             const int MOD = 1e9 + 7;
             int a{}, b{1};
             for (int i{}; i < n; ++i) tie(a, b) = pair(b, a % MOD + b % MOD);
             return a % MOD;
         }
     };
     ```

2.   [509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/);

     ```cpp
     vector<int> a(31, -1);
     class Solution {
     public:
         int fib(int n) {
             if (a[n] == -1) {
                 if (n <= 1)
                     a[n] = n;
                 else
                     a[n] = fib(n - 1) + fib(n - 2);
             }
             return a[n];
         }
     };
     // 滚动数组优化
     class Solution {
     public:
         int fib(int n) {
             int a{}, b{1};
             for (int i{}; i < n; ++i) {
                 int tmp = b;
                 b += a;
                 a = tmp;
             }
             return a;
         }
     };
     ```
     
     



# 路径问题

1.   [62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/);(经典的二维DP问题)

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             vector<vector<int>> dp(m, vector<int>(n));
             for (int i{}; i < n; ++i) dp[0][i] = 1;
             for (int j{1}; j < m; ++j) dp[j][0] = 1;
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
             return dp[m - 1][n - 1];
         }
     };
     ```

     滚动数组优化:

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             vector<int> dp(n, 1);
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j) dp[j] += dp[j - 1];
             return dp[n - 1];
         }
     };
     ```

     组合数学公式方法也可以:(注意这里`ans=ans*...`是必须的, 因为如果写成`ans*=...`会导致除法舍入)

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             long ans{1};
             for (int i{}; i < m - 1; ++i) ans = ans * (n + i) / (i + 1);
             return ans;
         }
     };
     ```

     

2.   [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/);

     ```cpp
     class Solution {
     public:
         int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
             int m = obstacleGrid.size(), n = obstacleGrid[0].size();
             if (obstacleGrid[0][0]) return 0; // 注意初始值为障碍物, 后面不需要考虑
     
             vector<vector<int>> dp(m, vector<int>(n));
             int i{}, j{1};
             for (; i < n && obstacleGrid[0][i] != 1; ++i) dp[0][i] = 1;
             for (; j < m && obstacleGrid[j][0] != 1; ++j) dp[j][0] = 1;
             for (i = 1; i < m; ++i)
                 for (j = 1; j < n; ++j)
                     if (obstacleGrid[i][j] == 0)
                         dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
             return dp[m - 1][n - 1];
         }
     };
     ```

     同样可以滚动数组优化:(有点技巧, 参考了官方题解)

     ```cpp
     class Solution {
     public:
         int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
             int m = obstacleGrid.size(), n = obstacleGrid[0].size();
             vector<int> dp(n);
             dp[0] = obstacleGrid[0][0] != 1;
             for (int i{}; i < m; ++i)
                 for (int j{}; j < n; ++j) {
                     if (obstacleGrid[i][j]) {
                         dp[j] = 0;
                         continue;
                     }
                     if (j && obstacleGrid[i][j - 1] == 0) dp[j] += dp[j - 1];
                 }
             return dp[n - 1];
         }
     };
     ```

     

3.   [64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/);

4.   [980. 不同路径 III - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-iii/);

5.   





# 序列/子序列/子数组

## 子序列

1.   [674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/);

     DP做法:

     ```cpp
     class Solution {
     public:
         int findLengthOfLCIS(vector<int>& nums) {
             int n = nums.size();
             vector<int> dp(n, 1);
             dp[0] = 1;
             for (int i{1}; i < n; ++i)
                 if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
     
             return *max_element(dp.begin(), dp.end());
         }
     };
     ```

     贪心也能做:(最优方法, 空间复杂度$O(1)$)

     ```cpp
     class Solution {
     public:
         int findLengthOfLCIS(vector<int>& nums) {
             int pre = INT_MIN, ans{}, tmp{};
             for (auto num : nums) {
                 if (num > pre)
                     tmp++;
                 else
                     ans = max(ans, tmp), tmp = 1;
                 pre = num;
             }
             return max(ans, tmp);
         }
     };
     ```

     

2.   [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/);(贪心也可以做)

     ```cpp
     class Solution {
     public:
         int lengthOfLIS(vector<int>& nums) {
             int n = nums.size();
             vector<int> dp(n, 1);
             for (int i{1}; i < n; ++i)
                 for (int j{}; j < i; ++j)
                     if (nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1);
             return *max_element(dp.begin(), dp.end());
         }
     };
     ```

3.   [1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/);[剑指 Offer II 095. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/qJnOS7/);

     ```cpp
     class Solution {
     public:
         int longestCommonSubsequence(string text1, string text2) {
             int n1 = text1.size(), n2 = text2.size();
             vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));
             for (int i{1}; i <= n1; ++i)
                 for (int j{1}; j <= n2; ++j) {
                     if (text1[i - 1] == text2[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     else
                         dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                 }
             return dp[n1][n2];
         }
     };
     //非STL
     class Solution {
     public:
         int longestCommonSubsequence(string s1, string s2) {
         	int n = s1.size(), m = s2.size();
         	int f[n+1][m+1];
         	memset(f, 0, sizeof(f));
         	for(int i = 1; i <= n; i++) 
         		for(int j = 1; j <= m; j++) 
         			if(s1[i-1] == s2[j-1])
         				f[i][j] = f[i-1][j-1] + 1;
         			else
         				f[i][j] = max(f[i-1][j], f[i][j-1]);
         	return f[n][m];
         }
     };
     ```

4.   [1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/);(和LCS类似)

5.   [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/);(双指针也能做, DP普适性好, 编辑距离入门)

     ```cpp
     class Solution {
     public:
         bool isSubsequence(string s, string t) {
             int s1 = s.size(), t1 = t.size();
             vector<vector<int>> dp(s1 + 1, vector<int>(t1 + 1));
             for (int i{1}; i <= s1; ++i)
                 for (int j{1}; j <= t1; ++j)
                     if (s[i - 1] == t[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     else
                         dp[i][j] = dp[i][j - 1];
             return dp[s1][t1] == s1;
         }
     };
     ```

6.   [115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/);

     ```cpp
     
     class Solution {
     public:
         int numDistinct(string s, string t) {
             int m = s.size(), n = t.size();
             int dp[m + 1][n + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{0}; i <= m; ++i) dp[i][0] = 1;
             for (int i{1}; i <= m; ++i)
                 for (int j{1}; j <= n; ++j)
                     if (s[i - 1] == t[j - 1])
                         dp[i][j] = 1ll * dp[i - 1][j - 1] + dp[i - 1][j];
                     else
                         dp[i][j] = dp[i - 1][j];
             return dp[m][n];
         }
     };
     ```

7.   [583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/)

     ```cpp
     class Solution {
     public:
         int minDistance(string word1, string word2) {
             int n1 = word1.size(), n2 = word2.size();
             int dp[n1 + 1][n2 + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{}; i <= n1; ++i) dp[i][0] = i;
             for (int j{1}; j <= n2; ++j) dp[0][j] = j;
             for (int i{1}; i <= n1; ++i)
                 for (int j{1}; j <= n2; ++j)
                     // 不需要删除
                     if (word1[i - 1] == word2[j - 1])
                         dp[i][j] = dp[i - 1][j - 1];
                     else
                         dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1;
             return dp[n1][n2];
         }
     };
     ```

     

8.   [72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/);(终极boss)

     ```cpp
     class Solution {
     public:
         int minDistance(string word1, string word2) {
             int m = word1.size(), n = word2.size();
             int dp[m + 1][n + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{}; i <= m; ++i) dp[i][0] = i;
             for (int j{1}; j <= n; ++j) dp[0][j] = j;
             for (int i{1}; i <= m; ++i)
                 for (int j{1}; j <= n; ++j)
                     if (word1[i - 1] == word2[j - 1])
                         dp[i][j] = dp[i - 1][j - 1];
                     else
                         dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
             return dp[m][n];
         }
     };
     ```



## 回文问题

1.   [647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/);

     ```cpp
     class Solution {
     public:
         int countSubstrings(string s) {
             int n = s.size(), ans{};
             bool dp[n][n];
             memset(dp, false, sizeof(dp));
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i}; j < n; ++j)
                     if (s[i] == s[j])
                         if (j - i <= 1)
                             dp[i][j] = true, ans++;
                         else if (dp[i + 1][j - 1])
                             dp[i][j] = true, ans++;
             return ans;
         }
     };
     ```

     

2.   [516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/);

     ```cpp
     class Solution {
     public:
         int longestPalindromeSubseq(string s) {
             int n = s.size();
             int dp[n][n];
             memset(dp, 0, sizeof(dp));
             for (int i{n - 1}; i >= 0; --i) dp[i][i] = 1;
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i + 1}; j < n; ++j)
                     if (s[i] == s[j])
                         dp[i][j] = dp[i + 1][j - 1] + 2;
                     else
                         dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
             return dp[0][n - 1];
         }
     };
     ```

     

3.   [5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/);(回文子串那个题的基础上加上更新最大值的操作即可)

     ```cpp
     class Solution {
     public:
         string longestPalindrome(string s) {
             int n = s.size(), maxL{}, st{};
             bool dp[n][n];
             memset(dp, false, sizeof(dp));
             for (int i{}; i < n; ++i) dp[i][i] = true;
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i}; j < n; ++j) {
                     if (s[i] == s[j])
                         if (j - i <= 1)
                             dp[i][j] = true;
                         else if (dp[i + 1][j - 1])
                             dp[i][j] = dp[i + 1][j - 1];
                     // 更新
                     if (dp[i][j] && j - i + 1 > maxL) maxL = j - i + 1, st = i;
                 }
             return s.substr(st, maxL);
         }
     };
     ```

     

4.   




## 序列

1.   [128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/);

     ```cpp
     ```

     

2.   [1691. 堆叠长方体的最大高度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/);

5.   [354. 俄罗斯套娃信封问题 - 力扣（LeetCode）](https://leetcode.cn/problems/russian-doll-envelopes/);

6.   





## 子数组(连续的子序列)

1.   [718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/);

     ```cpp
     class Solution {
     public:
         int findLength(vector<int> &nums1, vector<int> &nums2) {
             int n1 = nums1.size(), n2 = nums2.size();
             vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));
             int ans{}, i{}, j{};
             for (i = 1; i <= n1; ++i)
                 for (j = 1; j <= n2; ++j) {
                     if (nums1[i - 1] == nums2[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     if (dp[i][j] > ans) ans = dp[i][j];
                 }
             return ans;
         }
     };
     // 滚动数组
     class Solution {
     public:
         int findLength(vector<int> &nums1, vector<int> &nums2) {
             int n1 = nums1.size(), n2 = nums2.size();
             vector<int> dp(n2 + 1);
             int ans{}, i{}, j{};
             for (i = 1; i <= n1; ++i)
                 for (j = n2; j > 0; --j) {
                     if (nums1[i - 1] == nums2[j - 1])
                         dp[j] = dp[j - 1] + 1;
                     else
                         dp[j] = 0;
                     if (dp[j] > ans) ans = dp[j];
                 }
             return ans;
         }
     };
     ```

2.   [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)

     ```cpp
     class Solution {
     public:
         int maxSubArray(vector<int> &nums) {
             int n = nums.size();
             vector<int> dp(n);
             dp[0] = nums[0];
             for (int i{1}; i < n; ++i) dp[i] = max(nums[i], dp[i - 1] + nums[i]);
             return *max_element(dp.begin(), dp.end());
         }
     };
     // 滚动数组
     class Solution {
     public:
         int maxSubArray(vector<int> &nums) {
             int n = nums.size();
             if (n == 1) return nums[0];
             int a{nums[0]}, b{}, ans{INT_MIN};
             for (int i{1}; i < n; ++i)
                 b = max(nums[i], a + nums[i]), ans = max({a, b, ans}), a = b;
             return ans;
         }
     };
     ```

     

3.   



# 背包问题



## 完全背包

1.   [322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/);
2.   [518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/);
3.   











# 数位DP(难, 本质上是记忆化深搜)

>   [数位 DP 通用模板，附题单（Python/Java/C++/Go） - 不含连续1的非负整数 - 力扣（LeetCode）](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/solution/by-endlesscheng-1egu/);

1.   [600. 不含连续1的非负整数 - 力扣（LeetCode）](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/);
2.   [233. 数字 1 的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-digit-one/);
3.   [面试题 17.06. 2出现的次数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-2s-in-range-lcci/);
4.   [902. 最大为 N 的数字组合 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/);
5.   [1012. 至少有 1 位重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-with-repeated-digits/);
6.   [1397. 找到所有好字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-good-strings/);
7.   

