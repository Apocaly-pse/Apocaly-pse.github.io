---
tags: DSA LeetCode C++
---





# 组合类回溯

1.   [77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> combine(int n, int k) {
             vector<int> path{};
             vector<vector<int>> ans{};
     
             function<void(int)> f = [&](int start) {
                 if (path.size() == k) {
                     ans.emplace_back(path);
                     return;
                 }
                 // 剪枝: 考虑**还需要**选取的元素个数
                 for (int i{start}; i <= n - (k - path.size()) + 1; ++i) {
                 // for (int i{start}; i <= n; ++i) {
                     path.emplace_back(i);
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(1);
             return ans;
         }
     };
     ```

2.   [216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> combinationSum3(int k, int n) {
             vector<vector<int>> ans{};
             vector<int> path{};
             int used[9]{}, sum{};
             function<void()> f = [&]() {
                 if (path.size() == k && sum == n) {
                     ans.emplace_back(path);
                     return;
                 }
                 for (int i{1}; i <= 9; ++i) {
                     if (used[i - 1]) break;
                     path.emplace_back(i);
                     sum += i;
                     used[i - 1] = 1;
                     f();
                     path.pop_back();
                     used[i - 1] = 0;
                     sum -= i;
                 }
             };
             f();
             return ans;
         }
     };
     ```

     剪枝, 优化一下(不使用额外数组):
     ```cpp
     class Solution {
     public:
         vector<vector<int>> combinationSum3(int k, int n) {
             vector<vector<int>> ans{};
             vector<int> path{};
             int sum{};
             function<void(int)> f = [&](int start) {
                 if (sum > n) return; // 剪枝
                 if (path.size() == k && sum == n) {
                     ans.emplace_back(path);
                     return;
                 }
                 // 剪枝
                 for (int i{start}; i <= 9 - (k - path.size()) + 1; ++i) {
                     if (sum + i > n) break; // 剪枝
                     path.emplace_back(i);
                     sum += i;
                     f(i + 1);
                     path.pop_back();
                     sum -= i;
                 }
             };
             f(1);
             return ans;
         }
     };
     ```

3.   [17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/);

     ```cpp
     class Solution {
     public:
         vector<string> letterCombinations(string digits) {
             if (digits.empty()) return {};
             unordered_map<char, string> dic{
                 {'2', "abc"}, {'3', "def"},  {'4', "ghi"}, {'5', "jkl"},
                 {'6', "mno"}, {'7', "pqrs"}, {'8', "tuv"}, {'9', "wxyz"}};
             vector<string> ans{};
             string path{};
     
             function<void(int)> f = [&](int d) {
                 if (path.size() == digits.size()) {
                     ans.emplace_back(path);
                     return;
                 }
                 for (char c : dic[digits[d]]) {
                     path.push_back(c);
                     f(d + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

     

4.   [39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
             int n = candidates.size(), sum{};
             vector<int> path{};
             vector<vector<int>> ans{};
             sort(candidates.begin(), candidates.end());
     
             function<void(int)> f = [&](int start) {
                 if (sum == target) {
                     ans.emplace_back(path);
                     return;
                 }
                 for (int i{start}; i < n && candidates[i] + sum <= target; ++i) {
                     path.emplace_back(candidates[i]);
                     sum += candidates[i];
                     f(i);
                     path.pop_back();
                     sum -= candidates[i];
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

     

5.   [40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
             int n = candidates.size(), sum{};
             vector<int> path{}, used(n);
             vector<vector<int>> ans{};
             sort(candidates.begin(), candidates.end());
     
             function<void(int)> f = [&](int start) {
                 if (sum == target) {
                     ans.emplace_back(path);
                     return;
                 }
                 for (int i{start}; i < n && candidates[i] + sum <= target; ++i) {
                     if (i && candidates[i] == candidates[i - 1] && !used[i - 1]) continue;
                     path.emplace_back(candidates[i]);
                     sum += candidates[i];
                     used[i] = 1;
                     f(i + 1);
                     path.pop_back();
                     sum -= candidates[i];
                     used[i] = 0;
                 }
             };
             f(0);
             return ans;
         }
     };
     ```
     



# 分割问题

可以转化为组合型回溯. 

1.   [131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/);[剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/);

     ```cpp
     class Solution {
     public:
         vector<vector<string>> partition(string s) {
             auto isPalindrome = [&](int l, int r) {
                 for (; l < r; ++l, --r)
                     if (s[l] != s[r]) return false;
                 return true;
             };
             vector<vector<string>> ans{};
             vector<string> path{};
             int n = s.size();
             function<void(int)> f = [&](int start) {
                 if (start == n) {
                     ans.emplace_back(path);
                     return;
                 }
                 for (int i{start}; i < n; ++i) {
                     if (!isPalindrome(start, i)) continue;
                     path.emplace_back(s.substr(start, i - start + 1));
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```
     
     
     
2.   [93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/);  [剑指 Offer II 087. 复原 IP ](https://leetcode.cn/problems/0on3uN/);

     ```cpp
     class Solution {
     public:
         vector<string> restoreIpAddresses(string s) {
             int n = s.size();
             if (n > 12) return {};
             vector<string> ans{};
             // 判断分隔开的`数字`是否满足IP地址的条件
             auto check = [&](int l, int r) {
                 if (l > r) return false;                 // 区间不成立
                 if (s[l] == '0' && l != r) return false; // 含有前导零
                 int num{};
                 for (int i{l}; i <= r; ++i) {
                     if (s[i] < '0' || s[i] > '9') return false; // 非数字
                     num = 10 * num + s[i] - '0';
                     if (num > 255) return false;
                 }
                 return true;
             };
             int pointNum{};
             function<void(int)> f = [&](int start) {
                 if (pointNum == 3) {
                     if (check(start, n - 1)) ans.emplace_back(s);
                     return;
                 }
                 for (int i{start}; i < n; ++i) {
                     if (check(start, i)) {
                         s.insert(s.begin() + i + 1, '.');
                         ++pointNum, ++n;
                         f(i + 2); // 还要略过加的`.`
                         s.erase(s.begin() + i + 1);
                         --pointNum, --n;
                     } else
                         break;
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

     



# 排列类回溯: 计入顺序

1.   [46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> permute(vector<int>& nums) {
             int n = nums.size();
             vector<int> path{}, used(n);
             vector<vector<int>> ans{};
             
             function<void()> f = [&]() {
                 if (path.size() == n)
                     ans.emplace_back(path);
                 for (int i{}; i < n; ++i) {
                     if (used[i]) continue;
                     path.emplace_back(nums[i]);
                     used[i] = 1;
                     f();
                     path.pop_back();
                     used[i] = 0;
                 }
             };
             f();
             return ans;
         }
     };
     ```

2.   [47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/);(可重复排列, 注意去重)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> permuteUnique(vector<int>& nums) {
             int n = nums.size();
             sort(nums.begin(), nums.end());
             vector<int> path{}, used(n);
             vector<vector<int>> ans{};
             
             function<void()> f = [&]() {
                 if (path.size() == n)
                     ans.emplace_back(path);
     
                 for (int i{}; i < n; ++i) {
                     if(used[i]) continue;
                     if(i && nums[i] == nums[i - 1] && !used[i - 1]) continue;
                     path.emplace_back(nums[i]);
                     used[i] = 1;
                     f();
                     path.pop_back();
                     used[i] = 0;
                 }
             };
             f();
             return ans;
         }
     };
     ```
     
     





# 子集类回溯

其实就是组合的一个变种, 不需要记录顺序. 

1.   [剑指 Offer II 079. 所有子集 - 力扣（LeetCode）](https://leetcode.cn/problems/TVdhkn/);[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> subsets(vector<int>& nums) {
             vector<int> path{};
             vector<vector<int>> ans{};
             int n = nums.size();
     
             function<void(int)> f = [&](int start) {
                 ans.emplace_back(path); // 无条件, 直接记录
                 for (int i{start}; i < n; ++i) {
                     path.emplace_back(nums[i]);
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

2.   [90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/);(注意去重逻辑)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> subsetsWithDup(vector<int>& nums) {
             int n = nums.size();
             vector<int> path{}, used(n);
             vector<vector<int>> ans{};
             sort(nums.begin(), nums.end());
     
             function<void(int)> f = [&](int start) {
                 ans.emplace_back(path);
                 for (int i{start}; i < n; ++i) {
                     if (i && !used[i - 1] && nums[i] == nums[i - 1]) continue;
                     path.emplace_back(nums[i]);
                     used[i] = 1;
                     f(i + 1);
                     path.pop_back();
                     used[i] = 0;
                 }
             };
             f(0);
             return ans;
         }
     };
     ```



# 子序列类回溯

1.   [491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> findSubsequences(vector<int>& nums) {
             vector<int> path{};
             vector<vector<int>> ans{};
             int n = nums.size();
     
             function<void(int)> f = [&](int start) {
                 if (path.size() > 1)
                     ans.emplace_back(path);
     
                 unordered_set<int> uset{};
                 for (int i{start}; i < n; ++i) {
                     if ((!path.empty() && nums[i] < path.back()) || uset.count(nums[i]))
                         continue;
                     path.emplace_back(nums[i]);
                     uset.insert(nums[i]);
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

     用数组哈希也可以: (由于数据范围小)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> findSubsequences(vector<int>& nums) {
             vector<int> path{};
             vector<vector<int>> ans{};
             int n = nums.size();
     
             function<void(int)> f = [&](int start) {
                 if (path.size() > 1)
                     ans.emplace_back(path);
     
                 int uset[201]{};
                 for (int i{start}; i < n; ++i) {
                     if ((!path.empty() && nums[i] < path.back()) || uset[nums[i] + 100])
                         continue;
                     path.emplace_back(nums[i]);
                     uset[nums[i] + 100] = 1;
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

     

2.   



# 综合题

这里需要考虑二维数组上的回溯, 以及



## 重新安排行程

>   [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/);

```cpp
class Solution {
    unordered_map<string, map<string, int>> targets;

public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        function<bool(int, vector<string>&)> f = [&](int ticketNum,
                                                     vector<string>& res) {
            if (res.size() == ticketNum + 1) return true;
            for (auto& target : targets[res[res.size() - 1]]) {
                if (target.second) {
                    res.emplace_back(target.first);
                    target.second--;
                    if (f(ticketNum, res)) return true;
                    res.pop_back();
                    target.second++;
                }
            }
            return false;
        };
        vector<string> res;
        for (auto& vec : tickets) targets[vec[0]][vec[1]]++;
        res.emplace_back("JFK");
        f(tickets.size(), res);
        return res;
    }
};
```



## N皇后

>   [51. N 皇后](https://leetcode.cn/problems/n-queens/);
>
>   [52. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/);
>
>   [面试题 08.12. 八皇后](https://leetcode.cn/problems/eight-queens-lcci/);
>
>   上面的51和52其实是一个题, 因为第二问只是问数量
>
>   参考:
>
>   1.   [DFS + 位运算剪枝](https://leetcode.cn/problems/n-queens-ii/solution/dfs-wei-yun-suan-jian-zhi-by-makeex/);
>
>        

经典回溯题型, 其实跟前面的分割型问题类似, 需要自定义一个判断函数, 然后进入二维循环中进行判断:

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans{};
        vector<string> path(n, string(n, '.'));

        auto isValid = [&](int row, int col) {
            // 检查列中有无皇后
            for (int i{}; i <= row; ++i)
                if (path[i][col] == 'Q') return false;
            // 检查 左下<->右上 (45°)对角线有无皇后
            for (int i{row - 1}, j{col - 1}; i >= 0 && j >= 0; --i, --j)
                if (path[i][j] == 'Q') return false;
            // 检查 左上<->右下 (135°)对角线有无皇后
            for (int i{row - 1}, j{col + 1}; i >= 0 && j < n; --i, ++j)
                if (path[i][j] == 'Q') return false;
            return true;
        };

        function<void(int)> f = [&](int row) {
            if (row == n) {
                ans.emplace_back(path);
                return;
            }
            for (int col{}; col < n; ++col) {
                if (!isValid(row, col)) continue;
                path[row][col] = 'Q';
                f(row + 1);
                path[row][col] = '.';
            }
        };
        f(0);
        return ans;
    }
};
```



对于52题, 只需对ans返回值稍作改动:

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        int ans{};
        vector<string> path(n, string(n, '.'));

        auto isValid = [&](int row, int col) {
            // 检查列中有无皇后
            for (int i{}; i <= row; ++i)
                if (path[i][col] == 'Q') return false;
            // 检查 左下<->右上 (45°)对角线有无皇后
            for (int i{row - 1}, j{col - 1}; i >= 0 && j >= 0; --i, --j)
                if (path[i][j] == 'Q') return false;
            // 检查 左上<->右下 (135°)对角线有无皇后
            for (int i{row - 1}, j{col + 1}; i >= 0 && j < n; --i, ++j)
                if (path[i][j] == 'Q') return false;
            return true;
        };

        function<void(int)> f = [&](int row) {
            if (row == n) {
                ++ans;
                return;
            }
            for (int col{}; col < n; ++col) {
                if (!isValid(row, col)) continue;
                path[row][col] = 'Q';
                f(row + 1);
                path[row][col] = '.';
            }
        };
        f(0);
        return ans;
    }
};
```

不过, 看起来还是不够快, 需要经典的位运算技巧了:

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        int ans{};
        function<void(int, int, int, int)> f = [&](int row, int col, int ld,
                                                   int rd) {
            if (row >= n) {
                ++ans;
                return;
            }

            // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历
            int bits = ~(col | ld | rd) & ((1 << n) - 1);
            while (bits > 0) {
                int pick = bits & -bits;
                f(row + 1, col | pick, (ld | pick) << 1, (rd | pick) >> 1);
                bits &= bits - 1;
            }
        };
        f(0, 0, 0, 0);
        return ans;
    }
};
```



## 解数独

[37. 解数独](https://leetcode.cn/problems/sudoku-solver/);

做这道题之前需要先做一下`有效数独`这个题, 因为需要判断数独的可行性. 

>   [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/);
>
>   参考了: [双百的JAVA实现，通过Bit位标记](https://leetcode.cn/problems/valid-sudoku/solution/shuang-bai-de-javashi-xian-tong-guo-bitw-j2n6/);

这个题就是一个模拟, 需要注意取余的时候更新值. 

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int row[9]{}, col[9]{}, block[3][3]{};
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if ('.' == board[i][j]) continue;
                int num = board[i][j] - '1';
                if (row[i] & (1 << num)) return false;
                if (col[j] & (1 << num)) return false;
                if (block[i / 3][j / 3] & (1 << num)) return false;
                col[j] |= 1 << num, row[i] |= 1 << num;
                block[i / 3][j / 3] |= 1 << num;
            }
        }
        return true;
    }
};
```



然后就是正菜了: 解数独. 



```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        auto isValid = [&](int row, int col, char val) {
            for (int i{}; i < 9; ++i)
                if (board[i][col] == val) return false;
            for (int i{}; i < 9; ++i)
                if (board[row][i] == val) return false;
            int startRow{(row / 3) * 3}, startCol{(col / 3) * 3};
            for (int i{startRow}; i < 3 + startRow; ++i)
                for (int j{startCol}; j < 3 + startCol; ++j)
                    if (board[i][j] == val) return false;
            return true;
        };
        function<bool(void)> f = [&]() {
            for (int i{}; i < 9; ++i) {
                for (int j{}; j < 9; ++j) {
                    if (board[i][j] != '.') continue;
                    // 猜结果
                    for (char k{'1'}; k <= '9'; ++k)
                        if (isValid(i, j, k)) {
                            board[i][j] = k;
                            if (f()) return true;
                            board[i][j] = '.';
                        }
                    return false;
                }
            }
            return true;
        };
        f();
    }
};
```







## 24点游戏



这里就不得不提一下我之前写的8个8组成1000的回溯方法了, 这么一想回溯也没有那么难了. 





# 回溯: 使用迭代法







# 记忆化搜索

含有状态存储的深度优先搜索. 

1.   [1140. 石子游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/stone-game-ii/);
2.   







