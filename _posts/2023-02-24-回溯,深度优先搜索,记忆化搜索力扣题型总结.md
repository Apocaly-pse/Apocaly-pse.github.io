---
tags: DSA LeetCode C++
---



# 回溯: 深度优先搜索





## 组合类回溯

1.   [39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/);
2.   [40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/);



## 子集类回溯

1.   [剑指 Offer II 079. 所有子集 - 力扣（LeetCode）](https://leetcode.cn/problems/TVdhkn/);[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> subsets(vector<int>& nums) {
             int n = nums.size();
             vector<int> path{};
             vector<vector<int>> ans{};
             function<void(int)> f = [&](int start) {
                 ans.emplace_back(path);
                 for (int i = start; i < n; ++i) {
                     path.emplace_back(nums[i]);
                     f(i + 1);
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

2.   [90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/);(注意去重逻辑)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> subsetsWithDup(vector<int>& nums) {
             int n = nums.size();
             sort(nums.begin(), nums.end());
             vector<int> path{}, used(n);
             vector<vector<int>> ans{};
             function<void(int)> f = [&](int start) {
                 ans.emplace_back(path);
                 for (int i = start; i < n; ++i) {
                     // 去重
                     if (i && used[i - 1] == 0 && nums[i] == nums[i - 1]) 
                         continue;
                     path.emplace_back(nums[i]);
                     used[i] = 1;
                     f(i + 1);
                     used[i] = 0;
                     path.pop_back();
                 }
             };
             f(0);
             return ans;
         }
     };
     ```

     





# 记忆化搜索

含有状态存储的深度优先搜索. 

1.   [1140. 石子游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/stone-game-ii/);
2.   
