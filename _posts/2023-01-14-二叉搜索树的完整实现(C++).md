---
tags: DSA C++ Python 
---

# 写在前面

总结一下二叉搜索树的直接遍历数组的方法构建, 指定值的搜索, 结点的删除, 插入.



# 简介

>   **二叉查找树**（英语：Binary Search Tree），也称为**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree），是指一棵空树或者具有下列性质的[二叉树](https://zh.wikipedia.org/wiki/二叉树)：
>
>   1.  若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
>   2.  若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
>   3.  任意节点的左、右子树也分别为二叉查找树；
>
>   二叉查找树相比于其他数据结构的优势在于查找、插入的[时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度)较低。为$O(\log n)$。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如[集合](https://zh.wikipedia.org/wiki/集合_(计算机科学))、[多重集](https://zh.wikipedia.org/wiki/多重集)、[关联数组](https://zh.wikipedia.org/wiki/关联数组)等。

因为二叉搜索树很可能退化为链表(时间复杂度为树高, 链表的时候就是$O(n)$了), 这样的话就体现不出二叉搜索树作为一种树结构带来的时间复杂度上的提升了, 所以需要引入一种平衡结构, 称为平衡二叉搜索树, 其实就是树中任一节点的左子树和右子树高度之差不超过1的二叉搜索树. 

一些相关的力扣题目:(后面遇到还会提及)

1.   [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/);(性质)
2.   [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/);
3.   [1382. 将二叉搜索树变平衡 - 力扣（LeetCode）](https://leetcode.cn/problems/balance-a-binary-search-tree/);
4.   [701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/);
5.   

## 定义

1.  空树是二叉搜索树。
2.  若二叉搜索树的左子树不为空，则其左子树上所有点的权值均小于其根节点的值。
3.  若二叉搜索树的右子树不为空，则其右子树上所有点的权值均大于其根节点的值。
4.  二叉搜索树的左右子树均为二叉搜索树。

## 性质

1.   由二叉搜索树的递归定义可得，二叉搜索树的**中序遍历**权值的序列为非降的序列。时间复杂度为$O(n)$。

# API介绍

下面是二叉搜索树的一些常用API, 在这里介绍具体的实现思路. 

## 从数组构建

>   [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/);

这里其实是一个力扣原题, 递归很好想, 迭代重点是三个队列的模拟. 

因为数组已经有序了, 那么只需要每次找中间节点然后建树即可. 



## 添加节点

这里需要分情况讨论一下, 参考了[二叉搜索树 & 平衡树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/bst/);

>   定义 insert(v) 为在二叉搜索树o(o代表根节点)中插入一个值为 v 的新节点。
>
>   分类讨论如下：
>
>   -   若 o 为空，直接返回一个值为 v 的新节点。
>
>   -   若 o 的权值等于 v，该节点的附加域该值出现的次数自增 1。
>
>   -   若 o 的权值大于 v，在 o 的左子树中插入权值为 v 的节点。
>
>   -   若 o 的权值小于 v，在 o 的右子树中插入权值为 v 的节点。
>
>   时间复杂度为 $O(h)$, $h$为树高。



## 二叉搜索树的平衡化

>   [1382. 将二叉搜索树变平衡 - 力扣（LeetCode）](https://leetcode.cn/problems/balance-a-binary-search-tree/);

没错, 又是力扣原题.. 证明有点长, 其实就是一些trick, 数学归纳法和不等式变换. 

实现上可以通过官解的存数组然后递归构造的方法(递归构造方法就是前面的原题). 但是这里主要说一下通过树节点左旋和右旋得到平衡性的方法:



# C++实现