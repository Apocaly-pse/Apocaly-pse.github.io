---
tags: C++
---

# 写在前面

总结一下罗剑锋老师的C++实战课程中C++智能指针与内存管理的一些内容. API及示例部分参考了[^1].

# 智能指针概述

智能指针实际上是一个像`vector`一样的类模板, 所以不能使用`Delete`方法释放所指对象的内存, 因为智能指针可以自主管理初始化时候的指针, 在所指对象离开作用域时自动析构释放内存. 

常见的智能指针有

-   `shared_ptr` 
-   `unique_ptr` 
-   `weak_ptr` 

都定义在`memory`头文件中.

其他需要注意的点:

1.   智能指针对象没有定义加减操作;
2.   智能指针对象没有定义移动地址操作;
3.   智能指针对象不可以先声明后解引用, 否则相当于解引用空指针, 造成内存问题;

# shared_ptr

|        代码        | 操作与解释                                                   |
| :----------------: | :----------------------------------------------------------- |
| `shared_ptr<T> sp` | 声明空智能指针,指向T类型的对象                               |
|        `p`         | 用于条件判断, 若`p`指向一个对象, 则为true, 否则false         |
|        `*p`        | 解引用`p`, 得到其指向的对象                                  |
|      `p->mem`      | 等价于`(*p).mem`                                             |
|     `p.get()`      | 返回`p`中保存的指针, <br />若智能指针自动释放了其指向的对象, 则返回的指针为空指针 |
|    `swap(p, q)`    | 交换两智能指针变量                                           |
|    `p.swap(q)`     | 同上                                                         |

使用实例:(已忽略头文件)

```cpp
void t1() {
    shared_ptr<string> p1;
    shared_ptr<string> p11 = make_shared<string>("");
    shared_ptr<string> p12 = make_shared<string>("Hello!");
    shared_ptr<list<int>> p2;
    if (!p1) cout << "p1 is nullptr" << endl;

    if (p11 && p11->empty()) {
        cout << "p11 is not nullptr" << endl;
        *p11 = "hi";
    }
    cout << "p11=" << p11 << endl;
    cout << "*p11=" << *p11 << endl;
    /*
    p1 is nullptr
    p11 is not nullptr
    p11=0x600003b64010
    *p11=hi
    */
    cout << "p12=" << p12 << endl;
    cout << "*p12=" << *p12 << endl;
    /*p12=0x600003b68010
     *p12=Hello!*/
}

void t2() {
    int *x(new int(1024));
    // process(x);
    /* error: could not convert 'x' from 'int*' to 'std::shared_ptr<int>'*/
    process(shared_ptr<int>(
        x)); // ok, but memery be released,临时变量被销毁,引用计数已经为0
    int j = *x;
    cout << j << endl; // random value.
}
/*
当将一个智能指针类型绑定到一个普通指针上时候,
我们就将内存的管理责任交给了智能指针.
此时不应该再用内置指针访问智能指针所指向的内存了*/

void t3() {
    // do not use `.get()` init another shared_ptr
    shared_ptr<int> p(new int(42)); // refcnt=1
    // p.get()用于返回p中保存的指针, 小心使用, 若智能指针释放了其对象,
    // 返回的指针所指向的对象也消失了
    int *q = p.get();
    { // 两个独立的shared_ptr指向相同的内存
        shared_ptr<int> r(q); // 这块书上错了,少了r
    } // 作用域结束,q和q指向的内存都被销毁,导致p指向的内存已经被释放了,p成为悬空指针
    // 并且p被销毁时, 同一块内存会被二次delete
    int foo = *p;
    cout << foo << " " << p << endl;
}

void t4() {
    // use reset()
    shared_ptr<int> p;
    cout << typeid(p).name() << endl; // St10shared_ptrIiE
    // p=new int(102); // 不能将指针赋予shared_ptr
    p.reset(new int(102));            //智能指针p指向新的对象
    cout << typeid(p).name() << endl; // St10shared_ptrIiE

    // reset还会更新引用计数.
    if (!p.unique()) { //不是唯一的用户, 就分配一份新的拷贝
        p.reset(new int(*p));
    }
    *p += 10;
    cout << p << " " << *p << endl; // 112
}
```



# unique_ptr

每次只能指向一个对象, 且只能被一个对象拥有. 



## 基本操作



# ref

[^1]:C++ primer 5ed;

