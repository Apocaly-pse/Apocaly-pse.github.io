---
tags: DSA LeetCode C++ LinkedList Interview
---

# 写在前面

其实链表的题大多数都可以用**双指针**(快慢指针)来做, 只不过不像数组中的双指针那样左右移动, 链表(单链表)的双指针方法都是向后移动的. 

## 链表声明

这里是力扣通用的链表结构体声明. 

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

# 基本操作

## 链表增删改查

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/);

```cpp

```



## 反转

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/);[剑指 Offer II 024. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/UHnkqh/);
迭代法: (常见)

```cpp
class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        ListNode *cur = head, *pre = nullptr;
        while (cur) {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

递归写法: (可能会问)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode* ans = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return ans;
    }
};
```



## 找中间节点

[876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/);

快慢指针, 根据速度的不同分出来中间节点, 一次遍历即可. 

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (!head || !head->next) return head;
        auto fa = head, lo = head;
        while (fa && fa->next) lo = lo->next, fa = fa->next->next;
        return lo;
    }
};
```



## 合并

[1669. 合并两个链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-in-between-linked-lists/);

```cpp
class Solution {
public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
        auto l = list1;
        int c = b - a + 2;
        while (--a) l = l->next;
        auto r = l;
        while (c--) r = r->next;
        l->next = list2;
        auto cur = list2;
        while (cur->next) cur = cur->next;
        cur->next = r;
        return list1;
    }
};
```

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/);[剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode）](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/);

```cpp
```





# 基础题目

1.   [86. 分隔链表 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-list/);(直接创建两个链表模拟)

     ```cpp
     // 直接模拟
     class Solution {
     public:
         ListNode* partition(ListNode* head, int x) {
             if (!head || !head->next) return head;
             auto h1 = new ListNode, h2 = new ListNode;
             auto cur1{h1}, cur2{h2};
             while (head) {
                 if (head->val < x)
                     cur1->next = new ListNode(head->val), cur1 = cur1->next;
                 else
                     cur2->next = new ListNode(head->val), cur2 = cur2->next;
                 head = head->next;
             }
             auto ans = h1->next, head2 = h2->next;
             if (ans)
                 cur1->next = head2;
             else
                 ans = head2;
             delete h1;
             delete h2;
             return ans;
         }
     };
     
     // 不使用额外空间的方法
     class Solution {
     public:
         ListNode* partition(ListNode* head, int x) {
             auto large = new ListNode, small = new ListNode;
             auto cur1{large}, cur2{small};
             while (head) {
                 if (head->val >= x)
                     cur1->next = head, cur1 = cur1->next;
                 else
                     cur2->next = head, cur2 = cur2->next;
                 head = head->next;
             }
             cur1->next = nullptr;     // 断大的尾结点
             cur2->next = large->next; // 小的尾结点指向大的头的next
             auto ans = small->next;
             delete small;
             delete large;
             return ans;
         }
     };
     ```

     

2.   [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/);

     ```cpp
     class Solution {
     public:
         ListNode *removeNthFromEnd(ListNode *head, int n) {
             ListNode *dummy = new ListNode(0, head);
             auto first = dummy, second = dummy;
             while (n--) first = first->next;
             while (first && first->next) {
                 first = first->next;
                 second = second->next;
             }
             second->next = second->next->next;
             return dummy->next;
         }
     };
     ```

3.   [61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/);

     ```cpp
     // 直接模拟: 速度慢
     class Solution {
     public:
         ListNode* rotateRight(ListNode* head, int k) {
             if (k == 0 || !head) return head;
             ListNode *mid{head}, *cur{head};
             int len{};
             while (cur && cur->next) ++len, cur = cur->next;
             ++len;
             k %= len;
             if (k == 0) return head;
             int m = len - k;
             while (--m) mid = mid->next;
             ListNode* new_head = mid->next;
             mid->next = nullptr;
             cur->next = head;
             return new_head;
         }
     };
     
     // 闭合为环: 经典思路, 用到了取余性质, 事实就是运行时间的区别不大
     class Solution {
     public:
         ListNode* rotateRight(ListNode* head, int k) {
             if (!head || k == 0) return head;
             auto cur{head};
             int n{1};
             while (cur->next) cur = cur->next, ++n;
             k %= n;
             if (k == 0) return head;
             cur->next = head; // 连接成环
             k = n - k;
             while (--k) head = head->next; // 找断开的点
             auto ans{head->next};
             head->next = nullptr;
             return ans;
         }
     };
     ```

     

4.   [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/);

     ```cpp
     class Solution {
     public:
         bool hasCycle(ListNode *head) {
             auto f = head, l = head;
             while (1) {
                 if (!f || !f->next) return false;
                 f = f->next->next;
                 l = l->next;
                 if (f == l) return true;
             }
         }
     };
     ```

5.   $\bigstar$[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/);[剑指 Offer II 022. 链表中环的入口节点](https://leetcode.cn/problems/c32eOV/);(经典算法, 需要找一个等价关系)

     >   从相遇点到入环点的距离($c$)+$(n-1)$环周长等于头结点到入环点的长度. 

     ```cpp
     class Solution {
     public:
         ListNode *detectCycle(ListNode *head) {
             if (!head) return head;
             auto f = head, s = head;
             while (f) {
                 s = s->next;
                 if (!f->next) return nullptr; // 无环
                 f = f->next->next;
                 if (f == s) {
                     auto ptr = head;
                     while (ptr != s) ptr = ptr->next, s = s->next;
                     return ptr;
                 }
             }
             return nullptr;
         }
     };
     ```

     

6.   [83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/);

     双指针的方法: (比较复杂)

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             using lp = ListNode *;
             lp cur = head, pre{};
             bool flg{};
             while (cur) {
                 while (pre && cur && cur->val == pre->val)
                     cur = cur->next, flg = true;
                 if (flg) pre->next = cur, flg = false;
                 pre = cur;
                 if (!cur) break;
                 cur = cur->next;
             }
             return head;
         }
     };
     ```

     单指针其实就够用了:

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             ListNode *cur = head;
             while (cur->next) {
                 if (cur->val == cur->next->val)
                     cur->next = cur->next->next;
                 else
                     cur = cur->next;
             }
             return head;
         }
     };
     ```

     

7.   [82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/);
     双指针+哑结点

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             ListNode *dummy = new ListNode(-101, head), *cur = head, *pre = dummy;
             bool flg{};
             while (cur && cur->next) {
                 while (cur->next && cur->val == cur->next->val)
                     cur = cur->next, flg = true;
                 if (flg)
                     flg = false, pre->next = cur->next;
                 else
                     pre = cur; // 若此轮遍历后不是重复值, 更新pre
                 cur = cur->next;
             }
             return dummy->next;
         }
     };
     ```

     同样, 单指针也可以做, 框架与上一题一样:

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             ListNode *dummy = new ListNode(-101, head), *cur = dummy;
             while (cur->next && cur->next->next) {
                 if (cur->next->val == cur->next->next->val) {
                     int x = cur->next->val;
                     while (cur->next && cur->next->val == x)
                         cur->next = cur->next->next;
                 } else
                     cur = cur->next;
             }
             return dummy->next;
         }
     };
     ```

8.   







# 综合题目

## 回文链表

[234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/);[剑指 Offer II 027. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/aMhZSa/);[面试题 02.06. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list-lcci/);

直接存数组模拟可以做, $O(1)$空间有一定难度, 下面主要说$O(1)$做法, 综合了上述的很多基本操作.

-   找到中节点(奇数长度是中节点, 偶数长度是中间靠右的结点)
-   翻转中节点开始往后的后部分链表
-   对比两个部分, 判断回文情况

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        auto mid = find_mid(head), nhead = reverse(mid);
        while (nhead) {
            if (head->val != nhead->val) return false;
            head = head->next;
            nhead = nhead->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head) {
        ListNode *cur = head, *pre = nullptr;
        while (cur) {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    ListNode* find_mid(ListNode* head) {
        ListNode *fast = head, *low = head, *tmp{};
        while (fast && fast->next) {
            fast = fast->next->next;
            low = low->next;
        }
        return low;
    }
};
```





## 合并排序链表



[23. 合并K个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/);

```cpp
```





## 反转链表

### 指定区间

[92. 反转链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list-ii/);(用到三个指针的穿针引线法, 画个图就出来了)

```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        auto dummy = new ListNode(0, head), pre = dummy;
        for (int i{}; i < left - 1; ++i) pre = pre->next; // 左端指针
        auto cur = pre->next, post = cur;
        int cnt = right - left;
        for (int i{}; i < cnt; ++i) post = post->next;
        while (cnt--) {
            pre->next = cur->next;
            auto tmp = post->next;
            post->next = cur;
            cur->next = tmp;
            cur = pre->next;
        }
        auto ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

### 指定组

[25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/);

```cpp
```



# 设计题

## O(1)数据结构



## 跳表

[1206. 设计跳表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-skiplist/);(高级数据结构, 数据库常用)

```cpp
constexpr int MAX_LEVEL = 8; // 遵循Redis的zset数据结构的取法
constexpr double P_FACTOR = 0.25; // 每4个元素抽取一个元素分层(作为上一层的节点)

class Skiplist {
private:
    // static const int level = 8; // 层数
    int level;
    mt19937 gen{random_device{}()};        // 随机数生成器
    uniform_real_distribution<double> dis; // 随机数分布

    struct Node {
        int val;
        vector<Node *> forward;

        Node(int _val, int _max_level = MAX_LEVEL)
            : val(_val), forward(_max_level, nullptr) {}
    };

    Node *head; // 头结点

public:
    Skiplist() : head(new Node(-1)), level(0), dis(0, 1) {}

    ~Skiplist() { delete head; }

    int randomLevel() { // 更新层
        int lv{1};
        while (dis(gen) < P_FACTOR && level < MAX_LEVEL) ++lv;
        return lv;
    }

    void helper(int target, vector<Node *> &pre) { // 辅助函数
        auto p = head;
        for (int i{level - 1}; i >= 0; --i) {
            while (p->forward[i] && p->forward[i]->val < target)
                p = p->forward[i];
            pre[i] = p;
        }
    }

    bool search(int target) {
        vector<Node *> pre(level);
        helper(target, pre);
        auto p = pre[0]->forward[0]; // 归为最后一层
        return p && p->val == target;
    }

    void add(int num) {
        int lv = randomLevel();
        level = max(level, lv);
        vector<Node *> pre(level, head);
        helper(num, pre);
        auto newNode = new Node(num, lv);

        for (int i{}; i < lv; ++i) {
            // 更新i层的状态, 将当前元素的 forward 指向新的节点
            newNode->forward[i] = pre[i]->forward[i];
            pre[i]->forward[i] = newNode;
            // if (rand() % 2) break; // 50% 概率不插入新节点
        }
    }

    bool erase(int num) {
        vector<Node *> pre(level);
        helper(num, pre);

        auto p = pre[0]->forward[0];
        if (!p || p->val != num) return false;

        // 更新第 i 层状态, forward 指向被删除节点的下一跳
        for (int i{}; i < level && pre[i]->forward[i] == p; ++i)
            pre[i]->forward[i] = p->forward[i];

        delete p;
        // 更新当前 level
        while (level > 1 && head->forward[level - 1] == nullptr) --level;
        return true;
    }
};
```

