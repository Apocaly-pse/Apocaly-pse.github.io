---
tags: DSA LeetCode C++ LinkedList Interview
---

# 写在前面

其实链表的题大多数都可以用**双指针**(快慢指针)来做, 只不过不像数组中的双指针那样左右移动, 链表(单链表)的双指针方法都是向后移动的. 

## 链表声明

这里是力扣通用的链表结构体声明. 

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

# 基本操作

## 链表增删改查

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/);

```cpp

```



## 反转

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/);[剑指 Offer II 024. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/UHnkqh/);
迭代法: (常见)

```cpp
class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        ListNode *cur = head, *pre = nullptr;
        while (cur) {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

递归写法: (可能会问)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode* ans = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return ans;
    }
};
```



## 找中间节点

[876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/);

快慢指针, 根据速度的不同分出来中间节点, 一次遍历即可. 

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (!head || !head->next) return head;
        auto fa = head, lo = head;
        while (fa && fa->next) lo = lo->next, fa = fa->next->next;
        return lo;
    }
};
```



## 合并

[1669. 合并两个链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-in-between-linked-lists/);

```cpp
class Solution {
public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
        auto l = list1;
        int c = b - a + 2;
        while (--a) l = l->next;
        auto r = l;
        while (c--) r = r->next;
        l->next = list2;
        auto cur = list2;
        while (cur->next) cur = cur->next;
        cur->next = r;
        return list1;
    }
};
```

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/);[剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode）](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/);

```cpp
```





# 基础题目

1.   [86. 分隔链表 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-list/);(直接创建两个链表模拟)

     ```cpp
     ```

     

3.   [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/);

     ```cpp
     class Solution {
     public:
         ListNode *removeNthFromEnd(ListNode *head, int n) {
             ListNode *dummy = new ListNode(0, head);
             auto first = dummy, second = dummy;
             while (n--) first = first->next;
             while (first && first->next) {
                 first = first->next;
                 second = second->next;
             }
             second->next = second->next->next;
             return dummy->next;
         }
     };
     ```

4.   [61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/);

     ```cpp
     ```

     

5.   [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/);

     ```cpp
     class Solution {
     public:
         bool hasCycle(ListNode *head) {
             auto f = head, l = head;
             while (1) {
                 if (!f || !f->next) return false;
                 f = f->next->next;
                 l = l->next;
                 if (f == l) return true;
             }
         }
     };
     ```

     

7.   [83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/);

     双指针的方法: (比较复杂)

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             using lp = ListNode *;
             lp cur = head, pre{};
             bool flg{};
             while (cur) {
                 while (pre && cur && cur->val == pre->val)
                     cur = cur->next, flg = true;
                 if (flg) pre->next = cur, flg = false;
                 pre = cur;
                 if (!cur) break;
                 cur = cur->next;
             }
             return head;
         }
     };
     ```

     单指针其实就够用了:

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             ListNode *cur = head;
             while (cur->next) {
                 if (cur->val == cur->next->val)
                     cur->next = cur->next->next;
                 else
                     cur = cur->next;
             }
             return head;
         }
     };
     ```

     

8.   [82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/);
     双指针+哑结点

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             ListNode *dummy = new ListNode(-101, head), *cur = head, *pre = dummy;
             bool flg{};
             while (cur && cur->next) {
                 while (cur->next && cur->val == cur->next->val)
                     cur = cur->next, flg = true;
                 if (flg)
                     flg = false, pre->next = cur->next;
                 else
                     pre = cur; // 若此轮遍历后不是重复值, 更新pre
                 cur = cur->next;
             }
             return dummy->next;
         }
     };
     ```

     同样, 单指针也可以做, 框架与上一题一样:

     ```cpp
     class Solution {
     public:
         ListNode *deleteDuplicates(ListNode *head) {
             if (!head) return head;
             ListNode *dummy = new ListNode(-101, head), *cur = dummy;
             while (cur->next && cur->next->next) {
                 if (cur->next->val == cur->next->next->val) {
                     int x = cur->next->val;
                     while (cur->next && cur->next->val == x)
                         cur->next = cur->next->next;
                 } else
                     cur = cur->next;
             }
             return dummy->next;
         }
     };
     ```

9.   







# 综合题目

## 回文链表

[234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/);[剑指 Offer II 027. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/aMhZSa/);[面试题 02.06. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list-lcci/);

直接存数组模拟可以做, $O(1)$空间有一定难度, 下面主要说$O(1)$做法, 综合了上述的很多基本操作.

-   找到中节点(奇数长度是中节点, 偶数长度是中间靠右的结点)
-   翻转中节点开始往后的后部分链表
-   对比两个部分, 判断回文情况

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        auto mid = find_mid(head), nhead = reverse(mid);
        while (nhead) {
            if (head->val != nhead->val) return false;
            head = head->next;
            nhead = nhead->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head) {
        ListNode *cur = head, *pre = nullptr;
        while (cur) {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    ListNode* find_mid(ListNode* head) {
        ListNode *fast = head, *low = head, *tmp{};
        while (fast && fast->next) {
            fast = fast->next->next;
            low = low->next;
        }
        return low;
    }
};
```





## 合并排序链表



[23. 合并K个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/);

```cpp
```





## 反转链表

### 指定区间

[92. 反转链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list-ii/);(用到三个指针的穿针引线法, 画个图就出来了)

```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        auto dummy = new ListNode(0, head), pre = dummy;
        for (int i{}; i < left - 1; ++i) pre = pre->next; // 左端指针
        auto cur = pre->next, post = cur;
        int cnt = right - left;
        for (int i{}; i < cnt; ++i) post = post->next;
        while (cnt--) {
            pre->next = cur->next;
            auto tmp = post->next;
            post->next = cur;
            cur->next = tmp;
            cur = pre->next;
        }
        auto ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

### 指定组

[25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/);

```cpp
```



# 设计题

## O(1)数据结构



## 跳表

[1206. 设计跳表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-skiplist/);(高级数据结构, 数据库常用)

```cpp
```

