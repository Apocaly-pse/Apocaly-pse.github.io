---
tags: DSA LeetCode C++
---

# 基本哈希问题

1.   [剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/);

2.   [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/);

     ```cpp
     class Solution {
     public:
         bool isAnagram(string s, string t) {
             int cs[26];
             memset(cs,0,26*sizeof(int));
             for(int c1:s)cs[c1-'a']++;
             for(int c2:t)cs[c2-'a']--;
             for (int i{};i<26;++i)if(cs[i])return false;
             return true;
         }
     };
     ```

     

3.   [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/);

4.   [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/);

     ```cpp
     class Solution {
     public:
         vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
             unordered_set<int> ans, n1(nums1.begin(), nums1.end());
             for(int num:nums2)
                 if(n1.find(num)!=n1.end())
                     ans.insert(num);
             return vector<int>(ans.begin(),ans.end());
         }
     };
     ```

     

5.   [219. 存在重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/contains-duplicate-ii/);

     ```cpp
     ```

     

6.   $\bigstar$[128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/);

     直观做法, 排序+遍历, 但是不是最快的. 

     ```cpp
     class Solution {
     public:
         int longestConsecutive(vector<int> &nums) {
             sort(nums.begin(), nums.end());
             int ans{}, n = nums.size(), tmp{1};
             if (n < 2) return n;
             for (int i{1}; i < n; ++i) {
                 if (nums[i] == nums[i - 1] + 1)
                     tmp++;
                 else if (nums[i] == nums[i - 1])
                     continue;
                 else
                     ans = max(ans, tmp), tmp = 1;
             }
             return max(ans, tmp);
         }
     };
     ```

     哈希做法: (很巧妙的方法, 找一段连续序列的最小值, 即左端点, 然后开始递增找最长的序列)

     ```cpp
     class Solution {
     public:
         int longestConsecutive(vector<int> &nums) {
             unordered_set<int> st(make_move_iterator(nums.begin()),
                                   make_move_iterator(nums.end()));
             int ans{};
             for (const int &num : st) {
                 if (st.count(num - 1)) continue;
                 int cur = num, tmp = 1;
                 while (st.count(cur + 1)) ++cur, ++tmp;
                 ans = max(ans, tmp);
             }
             return ans;
         }
     };
     ```
     
     








# 数对问题

1.   [1512. 好数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-good-pairs/);(直接哈希存值)

     ```cpp
     class Solution {
     public:
         int numIdenticalPairs(vector<int> &nums) {
             unordered_map<int, int> cnt{};
             for (int num : nums) cnt[num]++;
             int ans{};
             for (auto [_, v] : cnt) ans += v * (v - 1) / 2;
             return ans;
         }
     };
     ```

2.   [2342. 数位和相等数对的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/);

     ```cpp
     
     class Solution {
         public:
         int f(int n) {
             int ans{};
             while (n) ans += n % 10, n /= 10;
             return ans;
         }
         int maximumSum(vector<int>& nums) {
             unordered_map<int, int> cnt{};
             int ans{}, tmp{};
             for (int num : nums) {
                 tmp = f(num);
                 if (cnt[tmp]) ans = max(ans, num + cnt[tmp]);
                 cnt[tmp] = max(num, cnt[tmp]);
             }
             return ans == 0 ? -1 : ans;
         }
     };
     ```

3.   [面试题 16.24. 数对和 - 力扣（LeetCode）](https://leetcode.cn/problems/pairs-with-sum-lcci/);(哈希可以做, 但是双指针更快, 有点像三数之和)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> pairSums(vector<int>& nums, int target) {
             unordered_map<int, int> cnt{};
             vector<vector<int>> ans;
             for (int num : nums) {
                 int t = target - num;
                 if (cnt[t]) {
                     ans.emplace_back(vector<int>{num, t});
                     cnt[t]--;
                 } else
                     cnt[num]++;
             }
             return ans;
         }
     };
     ```

     双指针:

     ```cpp
     ```

     

4.   [646. 最长数对链 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-pair-chain/);

5.   [2364. 统计坏数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-bad-pairs/);

6.   

7.   [2354. 优质数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-excellent-pairs/);



