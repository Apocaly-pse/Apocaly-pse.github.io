---
tags: DSA LeetCode C++
---

# 基本哈希问题

1.   [剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/);

2.   [2395. 和相等的子数组](https://leetcode.cn/problems/find-subarrays-with-equal-sum/);

     ```cpp
     class Solution {
     public:
         bool findSubarrays(vector<int>& nums) {
             int n = nums.size();
             unordered_set<int> cnt{};
             for (int i{1}; i < n; ++i) {
                 if (cnt.count(nums[i - 1] + nums[i])) return true;
                 cnt.insert(nums[i - 1] + nums[i]);
             }
             return false;
         }
     };
     ```

     

3.   [2363. 合并相似的物品 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-similar-items/);

     ```cpp
     class Solution {
     public:
         vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {
             unordered_map<int, int> dic{};
             vector<vector<int>> ans{};
             for (auto a : items1) dic[a[0]] += a[1];
             for (auto b : items2) dic[b[0]] += b[1];
             for (auto [k, v] : dic) ans.emplace_back(vector<int>{k, v});
             sort(ans.begin(), ans.end());
             return ans;
         }
     };
     ```

     或者用数组哈希:
     ```cpp
     class Solution {
     public:
         vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {
             int dic[1001]{};
             vector<vector<int>> ans{};
             for (auto a : items1) dic[a[0]] += a[1];
             for (auto b : items2) dic[b[0]] += b[1];
             for (int i{}; i < 1001; ++i) 
                 if (dic[i])
                     ans.emplace_back(vector<int>{i, dic[i]});
             return ans;
         }
     };
     ```

     

4.   [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/);

     ```cpp
     class Solution {
     public:
         bool isAnagram(string s, string t) {
             int cs[26];
             memset(cs,0,26*sizeof(int));
             for(int c1:s)cs[c1-'a']++;
             for(int c2:t)cs[c2-'a']--;
             for (int i{};i<26;++i)if(cs[i])return false;
             return true;
         }
     };
     ```

     

5.   [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/);

6.   [LCP 18. 早餐组合 - 力扣（LeetCode）](https://leetcode.cn/problems/2vYnGI/);(类似两数之和)

     ```cpp
     
     
     
     // 或者数组哈希
     class Solution {
     public:
         const int MOD = 1e9 + 7;
         int breakfastNumber(vector<int>& staple, vector<int>& drinks, int x) {
             int n = staple.size();
             long long ans{};
             int tmp[x + 1];
             memset(tmp, 0, sizeof(tmp));
             for (int st : staple)
                 if (st < x)
                     ++tmp[st];
             for (int i{2}; i < x; ++i)
                 tmp[i] += tmp[i - 1];
             for (int dr : drinks)
                 if (x - dr > 0)
                     ans += tmp[x - dr];
             
             return ans % MOD;
         }
     };
     ```

     

7.   [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/);

     ```cpp
     class Solution {
     public:
         vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
             unordered_set<int> ans, n1(nums1.begin(), nums1.end());
             for(int num:nums2)
                 if(n1.find(num)!=n1.end())
                     ans.insert(num);
             return vector<int>(ans.begin(),ans.end());
         }
     };
     ```

     

8.   [219. 存在重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/contains-duplicate-ii/);

     ```cpp
     ```

     

9.   $\bigstar$[128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/);

     直观做法, 排序+遍历, 但是不是最快的. 

     ```cpp
     class Solution {
     public:
         int longestConsecutive(vector<int> &nums) {
             sort(nums.begin(), nums.end());
             int ans{}, n = nums.size(), tmp{1};
             if (n < 2) return n;
             for (int i{1}; i < n; ++i) {
                 if (nums[i] == nums[i - 1] + 1)
                     tmp++;
                 else if (nums[i] == nums[i - 1])
                     continue;
                 else
                     ans = max(ans, tmp), tmp = 1;
             }
             return max(ans, tmp);
         }
     };
     ```

     哈希做法: (很巧妙的方法, 找一段连续序列的最小值, 即左端点, 然后开始递增找最长的序列)

     ```cpp
     class Solution {
     public:
         int longestConsecutive(vector<int> &nums) {
             unordered_set<int> st(make_move_iterator(nums.begin()),
                                   make_move_iterator(nums.end()));
             int ans{};
             for (const int &num : st) {
                 if (st.count(num - 1)) continue;
                 int cur = num, tmp = 1;
                 while (st.count(cur + 1)) ++cur, ++tmp;
                 ans = max(ans, tmp);
             }
             return ans;
         }
     };
     ```

10.   [1817. 查找用户活跃分钟数 - 力扣（LeetCode）](https://leetcode.cn/problems/finding-the-users-active-minutes/);

      ```cpp
      class Solution {
      public:
          vector<int> findingUsersActiveMinutes(vector<vector<int>> &logs,
                                                int k) {
              unordered_map<int, unordered_set<int>> d;
              for (auto &log : logs) d[log[0]].insert(log[1]);
      
              vector<int> ans(k);
              for (auto &[_, ts] : d) ++ans[ts.size() - 1];
              return ans;
          }
      };
      ```

      

11.   [1604. 警告一小时内使用相同员工卡大于等于三次的人 - 力扣（LeetCode）](https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/);

      ```cpp
      class Solution {
      public:
          vector<string> alertNames(vector<string> &keyName,
                                    vector<string> &keyTime) {
              vector<string> ans{};
              unordered_map<string, vector<int>> dict{};
              for (int i{}; i < keyName.size(); ++i) {
                  string s{keyTime[i]};
                  int h = (s[0] - '0') * 10 + (s[1] - '0');
                  int m = (s[3] - '0') * 10 + (s[4] - '0');
                  dict[keyName[i]].emplace_back(h * 60 + m);
              }
      
              for (auto &[k, v] : dict) {
                  int n = v.size();
                  if (n < 3) continue;
                  sort(v.begin(), v.end());
                  int cnt{1};
                  for (int i{}; i < n - 2; ++i) {
                      if (v[i + 2] - v[i] <= 60) {
                          ans.emplace_back(k);
                          break;
                      }
                  }
              }
              sort(ans.begin(), ans.end());
              return ans;
          }
      };
      ```

12.   [448. 找到所有数组中消失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/);(原地哈希)

      ```cpp
      // 直接哈希
      class Solution {
      public:
          vector<int> findDisappearedNumbers(vector<int>& nums) {
              unordered_set<int> st(nums.begin(), nums.end());
              vector<int> ans{};
              for (int i{1}; i <= nums.size(); ++i)
                  if (st.find(i) == st.end()) ans.emplace_back(i);
              return ans;
          }
      };
      // 原地哈希
      class Solution {
      public:
          vector<int> findDisappearedNumbers(vector<int>& nums) {
              int n = nums.size();
              for (int num : nums) nums[(num - 1) % n] += n;
              vector<int> ans{};
              for (int i{}; i < n; ++i)
                  if (nums[i] <= n) ans.emplace_back(i + 1);
              return ans;
          }
      };
      ```

13.   [1124. 表现良好的最长时间段 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-well-performing-interval/);

      典型题, 需要用到前缀和, 然后讨论正负值情况, 正值可以直接放入结果中(因为肯定是最大的), 负值的讨论是一个难点, 需要考虑查找的元素为原索引减一, 这个可以画个图结合例子加深理解. 

      >   例如对于`[6,6,6,9,9]`这个数组, 根据是否大于8转化成仅含有`{1, -1}`的序列: `[-1, -1, -1, 1, 1]`, 前缀和数组(首元素设为零, 长度为原数组长度+1)为: `[0, -1, -2, -3, -2, -1]`. 
      >
      >   那么这时候讨论的结果就是负值了, 需要考虑

      

      ```cpp
      ```

14.   [1487. 保证文件名唯一 - 力扣（LeetCode）](https://leetcode.cn/problems/making-file-names-unique/);

      ```cpp
      ```

15.   

      

# 设计哈希类

1.   [705. 设计哈希集合 - 力扣（LeetCode）](https://leetcode.cn/problems/design-hashset/);

     ```cpp
     // STL 版: 速度太慢了
     class MyHashSet {
         vector<int> v{};
     public:
         MyHashSet() {}
         
         void add(int key) {
             if (!contains(key))
                 v.emplace_back(key);
         }
         
         void remove(int key) {
             if (contains(key))
                 v.erase(std::remove(v.begin(), v.end(), key), v.end());
         }
         
         bool contains(int key) {
             return find(v.begin(), v.end(), key) != v.end();
         }
     };
     // 数组哈希: 空间占用太大
     class MyHashSet {
         bool v[1000005]{};
     public:
         MyHashSet() {}
         
         void add(int key) {
             if (!contains(key))
                 v[key] = true;
         }
         
         void remove(int key) {
             if (contains(key))
                 v[key] = false;
         }
         
         bool contains(int key) {
             return v[key];
         }
     };
     // 位运算+桶
     class MyHashSet {
         int v[31251]{};
     public:
         MyHashSet() {}
     
         void add(int key) {
             int a = key / 32, b = key % 32;
             v[a] = v[a] | (1 << b);
         }
         
         void remove(int key) {
             int a = key / 32, b = key % 32;
             v[a] = v[a] & ~(1 << b);
         }
         
         bool contains(int key) {
             int a = key / 32, b = key % 32;
             return ((v[a] >> b) & 1) == 1;
         }
     };
     // 用long, 降低内存占用
     class MyHashSet {
         long v[15700]{};
         const static int NUM = 64;
     public:
         MyHashSet() {}
     
         void add(int key) {
             int a = key / NUM, b = key % NUM;
             v[a] = v[a] | (1L << b);
         }
         
         void remove(int key) {
             int a = key / NUM, b = key % NUM;
             v[a] = v[a] & ~(1L << b);
         }
         
         bool contains(int key) {
             int a = key / NUM, b = key % NUM;
             return ((v[a] >> b) & 1L) == 1;
         }
     };
     // 哈希取模
     class MyHashSet {
     private:
         static const int base = 769;
         vector<list<int>> data;
         static int hash(int key) {
             return key % base;
         }
     public:
         MyHashSet() : data(base) {}
         
         void add(int key) {
             int h = hash(key);
             for (auto it = data[h].begin(); it != data[h].end(); it++) {
                 if ((*it) == key) {
                     return;
                 }
             }
             data[h].push_back(key);
         }
         
         void remove(int key) {
             int h = hash(key);
             for (auto it = data[h].begin(); it != data[h].end(); it++) {
                 if ((*it) == key) {
                     data[h].erase(it);
                     return;
                 }
             }
         }    
     
         bool contains(int key) {
             int h = hash(key);
             for (auto it = data[h].begin(); it != data[h].end(); it++) {
                 if ((*it) == key) {
                     return true;
                 }
             }
             return false;
         }
     };
     ```

2.   [706. 设计哈希映射 - 力扣（LeetCode）](https://leetcode.cn/problems/design-hashmap/);

     ```cpp
     // 数组哈希: 巨慢
     class MyHashMap {
         int v[1000001][2]{};
     public:
         MyHashMap() {}
         
         void put(int key, int value) {
             v[key][0] = 1, v[key][1] = value;
         }
         
         int get(int key) {
             return v[key][0] ? v[key][1] : -1;
         }
         
         void remove(int key) {
             v[key][0] = 0;
         }
     };
     // 桶
     
     // 哈希取模
     class MyHashMap {
     private:
         static const int base = 769;
         vector<list<pair<int, int>>> data;
         static int hash(int key) { return key % base; }
     
     public:
         MyHashMap() : data(base) {}
     
         void put(int key, int value) {
             int h = hash(key);
             for (auto it = data[h].begin(); it != data[h].end(); ++it)
                 if (it->first == key) {
                     it->second = value;
                     return;
                 }
             data[h].push_back({key, value});
         }
     
         int get(int key) {
             int h = hash(key);
             for (auto it = data[h].begin(); it != data[h].end(); ++it)
                 if (it->first == key) return it->second;
             return -1;
         }
     
         void remove(int key) {
             int h = hash(key);
             for (auto it = data[h].begin(); it != data[h].end(); ++it)
                 if (it->first == key) {
                     data[h].remove(*it);
                     return;
                 }
         }
     };
     
     ```

     







# 前缀和+哈希

1.   [1590. 使数组和能被 P 整除 - 力扣（LeetCode）](https://leetcode.cn/problems/make-sum-divisible-by-p/);

     ```cpp
     ```

1.   [面试题 17.05. 字母与数字 - 力扣（LeetCode）](https://leetcode.cn/problems/find-longest-subarray-lcci/);

     ```cpp
     ```

     




# 数对问题

1.   [1512. 好数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-good-pairs/);(直接哈希存值)

     ```cpp
     class Solution {
     public:
         int numIdenticalPairs(vector<int> &nums) {
             unordered_map<int, int> cnt{};
             for (int num : nums) cnt[num]++;
             int ans{};
             for (auto [_, v] : cnt) ans += v * (v - 1) / 2;
             return ans;
         }
     };
     ```

2.   [2342. 数位和相等数对的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/);

     ```cpp
     
     class Solution {
         public:
         int f(int n) {
             int ans{};
             while (n) ans += n % 10, n /= 10;
             return ans;
         }
         int maximumSum(vector<int>& nums) {
             unordered_map<int, int> cnt{};
             int ans{}, tmp{};
             for (int num : nums) {
                 tmp = f(num);
                 if (cnt[tmp]) ans = max(ans, num + cnt[tmp]);
                 cnt[tmp] = max(num, cnt[tmp]);
             }
             return ans == 0 ? -1 : ans;
         }
     };
     ```

3.   [面试题 16.24. 数对和 - 力扣（LeetCode）](https://leetcode.cn/problems/pairs-with-sum-lcci/);(哈希可以做, 但是双指针更快, 有点像三数之和)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> pairSums(vector<int>& nums, int target) {
             unordered_map<int, int> cnt{};
             vector<vector<int>> ans;
             for (int num : nums) {
                 int t = target - num;
                 if (cnt[t]) {
                     ans.emplace_back(vector<int>{num, t});
                     cnt[t]--;
                 } else
                     cnt[num]++;
             }
             return ans;
         }
     };
     ```

     双指针:

     ```cpp
     ```

     

4.   [646. 最长数对链 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-pair-chain/);

5.   [2364. 统计坏数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-bad-pairs/);

6.   [2354. 优质数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-excellent-pairs/);

7.   




# 设计数据结构



1.   [1797. 设计一个验证系统 - 力扣（LeetCode）](https://leetcode.cn/problems/design-authentication-manager/);

     ```cpp
     class AuthenticationManager {
         int ttl;
         unordered_map<string, int> dic;
     
     public:
         AuthenticationManager(int timeToLive) { ttl = timeToLive; }
     
         void generate(string tokenId, int currentTime) {
             dic[tokenId] = currentTime;
         }
     
         void renew(string tokenId, int currentTime) {
             if (dic.find(tokenId) != dic.end() && dic[tokenId] + ttl > currentTime)
                 dic[tokenId] = currentTime;
         }
     
         int countUnexpiredTokens(int currentTime) {
             int ans{};
             for (auto& [_, ct] : dic) ans += (ct + ttl > currentTime);
             return ans;
         }
     };
     ```

     



## 有序集合

1.   [剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/);[295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/);

     ```cpp
     class MedianFinder {
         multiset<int> nums;
         multiset<int>::iterator l, r;
     
     public:
         MedianFinder() : l(nums.end()), r(nums.end()) {}
     
         void addNum(int num) {
             int n = nums.size();
             nums.insert(num);
             if (!n) // 空
                 l = r = nums.begin();
             else if (n & 1) { // 奇数
                 if (num < *l)
                     --l;
                 else
                     ++r;
             } else { // 偶数
                 if (num > *l && num < *r)
                     ++l, --r;
                 else if (num >= *r)
                     ++l;
                 else
                     --r, l = r;
             }
         }
     
         double findMedian() { return (*l + *r) / 2.0; }
     };
     ```

     
