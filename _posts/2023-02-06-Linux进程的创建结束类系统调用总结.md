---
tags: Linux OS Syscall C
---

# 写在前面

总结一下Linux系统的进程创建/终止/等待等系统调用, 参考:

1.   Linux/Unix系统编程手册.

下面主要给出例子, 关于函数原型可以参考书中或者`man 2 syscall`(例如`man 2 fork`). 

>   测试环境: Ubuntu 20.04 x86_64
>
>   gcc-9

# 新进程的创建: fork()

用于创建新的进程, 创建出来的新进程称为子进程, 拥有和父进程一样的代码段/数据段/栈段/堆段. 

所以创建新进程的资源消耗较大, 后续采用多线程方式可以解决这个问题.

由于这个函数的设计比较奇怪, 有两个返回值, 在父进程中返回子进程的进程ID, 在子进程中返回0, 错误返回-1, 所以可以用下面的语句制定创建子进程之后的进一步操作: 

```c
pid_t childPid;

switch (childPid = fork()) {
    case -1:
        /* error handling */
    case 0: // child process
        /* actions to child */
    default:
        /* actions to parent */
}
```

下面主要讨论数据共享和文件(句柄)共享, 为探讨进程间通信做准备. 

## 数据共享

一个例子, 关于同时操作一份数据: 

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h> // pid_t
#include <unistd.h>    // fork
static int idata = 111;

int main(int argc, char *argv[]) {
    pid_t childPId;
    int istack = 222;

    switch (childPId = fork()) {
        case -1:
            fprintf(stderr, "fork error\n");
        case 0:
            idata *= 3;
            istack *= 3;
            break;
        default:
            sleep(3);
            break;
    }

    printf("PID=%ld %s idata=%d istack=%d\n", (long)getpid(),
           (childPId == 0) ? "(child) " : "(parent)", idata, istack);
    /* PID=526436 (child)  idata=333 istack=666 */
    /* PID=526435 (parent) idata=111 istack=222 */

    return 0;
}
```

## 文件共享

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>

int main(int argc, char* argv[]) {
    int fd, flags;
    char template[] = "/tmp/test-XXXXXX";
    setbuf(stdout, NULL);// 无缓冲

    fd = mkstemp(template);
    if (fd == -1) fprintf(stderr, "mkstemp");

    printf("File offset before fork: %lld\n",
           (long long)lseek(fd, 0, SEEK_CUR));

    flags = fcntl(fd, F_GETFL);

    if (flags == -1) fprintf(stderr, "fcntl - F_GETFL");
    printf("O_APPEND flag before fork() is %s\n",
           (flags & O_APPEND) ? "on" : "off");

    switch (fork()) {
        case -1:
            fprintf(stderr, "fork");
        case 0: // child
            if (lseek(fd, 1000, SEEK_SET) == -1) fprintf(stderr, "lseek");
            flags = fcntl(fd, F_GETFL);
            if (flags == -1) fprintf(stderr, "fcntl - F_GETFL");
            flags |= O_APPEND;
            if (fcntl(fd, F_SETFL, flags) == -1)
                fprintf(stderr, "fcntl - F_SETFL");
            _exit(EXIT_SUCCESS);
        default: // parent
            if (wait(NULL) == -1) fprintf(stderr, "wait");
            printf("child has exited\n");

            printf("file offset in parent is %lld\n",
                   (long long)lseek(fd, 0, SEEK_CUR));

            flags = fcntl(fd, F_GETFL);
            if (flags == -1) fprintf(stderr, "fcntl - F_GETFL");

            printf("O_APPEND in parent is %s\n",
                   (flags & O_APPEND) ? "on" : "off");
            exit(EXIT_SUCCESS);
    }
    return 0;
}
/* :!cc fork-file-shared.c && ./a.out */
/* File offset before fork: 0 */
/* O_APPEND flag before fork() is off */
/* child has exited */
/* file offset in parent is 1000 */
/* O_APPEND in parent is on */
```





## 新进程创建-节约资源版: vfork()

>   最好不要用vfork 

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int istack = 222;
    switch (vfork()) {
        case -1:
            fprintf(stderr, "vfork");
            exit(1);
        case 0: // child
            sleep(3);
            write(STDOUT_FILENO, "child executing\n", 16);
            istack *= 3;
            _exit(EXIT_SUCCESS);
        default:
            write(STDOUT_FILENO, "Parent executing\n", 17);
            printf("istack=%d\n", istack);
            exit(EXIT_SUCCESS);
    }
    return 0;
}
// 子进程对变量的修改影响了父进程的对应变量

/* child executing */
/* Parent executing */
/* istack=666 */
```

子进程会共享父进程的内存, 父进程会一直挂起直到子进程终止或者调用`exec`







# fork竞态条件与同步



## 竞态条件

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    int numChild, j;
    pid_t childPid;

    numChild = 100;
    setbuf(stdout, NULL); // 关闭缓存
    for (j = 0; j < numChild; ++j) {
        switch (childPid = fork()) {
            case -1:
                fprintf(stderr, "fork\n");
            case 0: // child
                printf("%d child\n", j);
                _exit(EXIT_SUCCESS);
            default: // parent
                printf("%d parent\n", j);
                wait(NULL);
                break;
        }
    }
    return 0;
}
```

几乎全是父进程先输出结果, 然后是子进程. 这就说明在Linux中fork执行之后会继续执行父进程, 而不是子进程. 

>   不过, 这也取决于内核的调度算法实现. 
>
>   所以不要对fork之后父子进程的执行顺序做任何假设, 如果一定要确保某一特定的执行顺序, 一定要采用某种进程间通信技术(同步技术), 例如: 文件锁, 信号量, 消息传送(基于管道, pipe). 



## 使用信号机制解决进程竞态条件



```c
```

