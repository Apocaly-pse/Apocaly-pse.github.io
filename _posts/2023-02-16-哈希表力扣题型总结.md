---
tags: DSA LeetCode C++
---

# 基本哈希问题

1.   [剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/);

2.   [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/);

     ```cpp
     class Solution {
     public:
         bool isAnagram(string s, string t) {
             int cs[26];
             memset(cs,0,26*sizeof(int));
             for(int c1:s)cs[c1-'a']++;
             for(int c2:t)cs[c2-'a']--;
             for (int i{};i<26;++i)if(cs[i])return false;
             return true;
         }
     };
     ```

     

3.   [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/);

4.   [LCP 18. 早餐组合 - 力扣（LeetCode）](https://leetcode.cn/problems/2vYnGI/);(类似两数之和)

     ```cpp
     
     
     
     // 或者数组哈希
     class Solution {
     public:
         const int MOD = 1e9 + 7;
         int breakfastNumber(vector<int>& staple, vector<int>& drinks, int x) {
             int n = staple.size();
             long long ans{};
             int tmp[x + 1];
             memset(tmp, 0, sizeof(tmp));
             for (int st : staple)
                 if (st < x)
                     ++tmp[st];
             for (int i{2}; i < x; ++i)
                 tmp[i] += tmp[i - 1];
             for (int dr : drinks)
                 if (x - dr > 0)
                     ans += tmp[x - dr];
             
             return ans % MOD;
         }
     };
     ```

     

5.   [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/);

     ```cpp
     class Solution {
     public:
         vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
             unordered_set<int> ans, n1(nums1.begin(), nums1.end());
             for(int num:nums2)
                 if(n1.find(num)!=n1.end())
                     ans.insert(num);
             return vector<int>(ans.begin(),ans.end());
         }
     };
     ```

     

6.   [219. 存在重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/contains-duplicate-ii/);

     ```cpp
     ```

     

7.   $\bigstar$[128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/);

     直观做法, 排序+遍历, 但是不是最快的. 

     ```cpp
     class Solution {
     public:
         int longestConsecutive(vector<int> &nums) {
             sort(nums.begin(), nums.end());
             int ans{}, n = nums.size(), tmp{1};
             if (n < 2) return n;
             for (int i{1}; i < n; ++i) {
                 if (nums[i] == nums[i - 1] + 1)
                     tmp++;
                 else if (nums[i] == nums[i - 1])
                     continue;
                 else
                     ans = max(ans, tmp), tmp = 1;
             }
             return max(ans, tmp);
         }
     };
     ```

     哈希做法: (很巧妙的方法, 找一段连续序列的最小值, 即左端点, 然后开始递增找最长的序列)

     ```cpp
     class Solution {
     public:
         int longestConsecutive(vector<int> &nums) {
             unordered_set<int> st(make_move_iterator(nums.begin()),
                                   make_move_iterator(nums.end()));
             int ans{};
             for (const int &num : st) {
                 if (st.count(num - 1)) continue;
                 int cur = num, tmp = 1;
                 while (st.count(cur + 1)) ++cur, ++tmp;
                 ans = max(ans, tmp);
             }
             return ans;
         }
     };
     ```

8.   [1817. 查找用户活跃分钟数 - 力扣（LeetCode）](https://leetcode.cn/problems/finding-the-users-active-minutes/);

     ```cpp
     class Solution {
     public:
         vector<int> findingUsersActiveMinutes(vector<vector<int>> &logs,
                                               int k) {
             unordered_map<int, unordered_set<int>> d;
             for (auto &log : logs) d[log[0]].insert(log[1]);
     
             vector<int> ans(k);
             for (auto &[_, ts] : d) ++ans[ts.size() - 1];
             return ans;
         }
     };
     ```

     

9.   [1604. 警告一小时内使用相同员工卡大于等于三次的人 - 力扣（LeetCode）](https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/);

     ```cpp
     class Solution {
     public:
         vector<string> alertNames(vector<string> &keyName,
                                   vector<string> &keyTime) {
             vector<string> ans{};
             unordered_map<string, vector<int>> dict{};
             for (int i{}; i < keyName.size(); ++i) {
                 string s{keyTime[i]};
                 int h = (s[0] - '0') * 10 + (s[1] - '0');
                 int m = (s[3] - '0') * 10 + (s[4] - '0');
                 dict[keyName[i]].emplace_back(h * 60 + m);
             }
     
             for (auto &[k, v] : dict) {
                 int n = v.size();
                 if (n < 3) continue;
                 sort(v.begin(), v.end());
                 int cnt{1};
                 for (int i{}; i < n - 2; ++i) {
                     if (v[i + 2] - v[i] <= 60) {
                         ans.emplace_back(k);
                         break;
                     }
                 }
             }
             sort(ans.begin(), ans.end());
             return ans;
         }
     };
     ```

10.   [448. 找到所有数组中消失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/);(原地哈希)

      ```cpp
      // 直接哈希
      class Solution {
      public:
          vector<int> findDisappearedNumbers(vector<int>& nums) {
              unordered_set<int> st(nums.begin(), nums.end());
              vector<int> ans{};
              for (int i{1}; i <= nums.size(); ++i)
                  if (st.find(i) == st.end()) ans.emplace_back(i);
              return ans;
          }
      };
      // 原地哈希
      class Solution {
      public:
          vector<int> findDisappearedNumbers(vector<int>& nums) {
              int n = nums.size();
              for (int num : nums) nums[(num - 1) % n] += n;
              vector<int> ans{};
              for (int i{}; i < n; ++i)
                  if (nums[i] <= n) ans.emplace_back(i + 1);
              return ans;
          }
      };
      ```

11.   [1124. 表现良好的最长时间段 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-well-performing-interval/);

      典型题, 需要用到前缀和, 然后讨论正负值情况, 正值可以直接放入结果中(因为肯定是最大的), 负值的讨论是一个难点, 需要考虑查找的元素为原索引减一, 这个可以画个图结合例子加深理解. 

      >   例如对于`[6,6,6,9,9]`这个数组, 根据是否大于8转化成仅含有`{1, -1}`的序列: `[-1, -1, -1, 1, 1]`, 前缀和数组(首元素设为零, 长度为原数组长度+1)为: `[0, -1, -2, -3, -2, -1]`. 
      >
      >   那么这时候讨论的结果就是负值了, 需要考虑

      

      ```cpp
      ```

      

# 设计哈希类

1.   [705. 设计哈希集合 - 力扣（LeetCode）](https://leetcode.cn/problems/design-hashset/);
2.   [706. 设计哈希映射 - 力扣（LeetCode）](https://leetcode.cn/problems/design-hashmap/);






# 数对问题

1.   [1512. 好数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-good-pairs/);(直接哈希存值)

     ```cpp
     class Solution {
     public:
         int numIdenticalPairs(vector<int> &nums) {
             unordered_map<int, int> cnt{};
             for (int num : nums) cnt[num]++;
             int ans{};
             for (auto [_, v] : cnt) ans += v * (v - 1) / 2;
             return ans;
         }
     };
     ```

2.   [2342. 数位和相等数对的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/);

     ```cpp
     
     class Solution {
         public:
         int f(int n) {
             int ans{};
             while (n) ans += n % 10, n /= 10;
             return ans;
         }
         int maximumSum(vector<int>& nums) {
             unordered_map<int, int> cnt{};
             int ans{}, tmp{};
             for (int num : nums) {
                 tmp = f(num);
                 if (cnt[tmp]) ans = max(ans, num + cnt[tmp]);
                 cnt[tmp] = max(num, cnt[tmp]);
             }
             return ans == 0 ? -1 : ans;
         }
     };
     ```

3.   [面试题 16.24. 数对和 - 力扣（LeetCode）](https://leetcode.cn/problems/pairs-with-sum-lcci/);(哈希可以做, 但是双指针更快, 有点像三数之和)

     ```cpp
     class Solution {
     public:
         vector<vector<int>> pairSums(vector<int>& nums, int target) {
             unordered_map<int, int> cnt{};
             vector<vector<int>> ans;
             for (int num : nums) {
                 int t = target - num;
                 if (cnt[t]) {
                     ans.emplace_back(vector<int>{num, t});
                     cnt[t]--;
                 } else
                     cnt[num]++;
             }
             return ans;
         }
     };
     ```

     双指针:

     ```cpp
     ```

     

4.   [646. 最长数对链 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-pair-chain/);

5.   [2364. 统计坏数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-bad-pairs/);

6.   [2354. 优质数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-excellent-pairs/);

7.   




# 设计数据结构



1.   [1797. 设计一个验证系统 - 力扣（LeetCode）](https://leetcode.cn/problems/design-authentication-manager/);

     ```cpp
     class AuthenticationManager {
         int ttl;
         unordered_map<string, int> dic;
     
     public:
         AuthenticationManager(int timeToLive) { ttl = timeToLive; }
     
         void generate(string tokenId, int currentTime) {
             dic[tokenId] = currentTime;
         }
     
         void renew(string tokenId, int currentTime) {
             if (dic.find(tokenId) != dic.end() && dic[tokenId] + ttl > currentTime)
                 dic[tokenId] = currentTime;
         }
     
         int countUnexpiredTokens(int currentTime) {
             int ans{};
             for (auto& [_, ct] : dic) ans += (ct + ttl > currentTime);
             return ans;
         }
     };
     ```

     
