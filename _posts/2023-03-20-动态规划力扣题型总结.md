---
tags: DSA LeetCode C++ DP
---

# C++ snippets

```cpp
ostream& operator<<(ostream& os, const vector<int>& v) {
    for (auto i : v) os << i << " ";
    return os << endl;
}

ostream& operator<<(ostream& os, const vector<vector<int>>& v) {
    for (auto i : v) os << i;
    return os;
}
```





# 入门

>   [Overlapping Subproblems Property in Dynamic Programming | DP-1 - GeeksforGeeks](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/);

1.   [剑指 Offer 10- I. 斐波那契数列 - 力扣（LeetCode）](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/);

     ```cpp
     class Solution {
     public:
         int fib(int n) {
             const int MOD = 1e9 + 7;
             int a{}, b{1};
             for (int i{}; i < n; ++i) tie(a, b) = pair(b, a % MOD + b % MOD);
             return a % MOD;
         }
     };
     ```

2.   [509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/);

     ```cpp
     vector<int> a(31, -1);
     class Solution {
     public:
         int fib(int n) {
             if (a[n] == -1) {
                 if (n <= 1)
                     a[n] = n;
                 else
                     a[n] = fib(n - 1) + fib(n - 2);
             }
             return a[n];
         }
     };
     // 滚动数组优化
     class Solution {
     public:
         int fib(int n) {
             int a{}, b{1};
             for (int i{}; i < n; ++i) {
                 int tmp = b;
                 b += a;
                 a = tmp;
             }
             return a;
         }
     };
     ```

3.   [70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/);

     ```cpp
     class Solution {
     public:
         int climbStairs(int n) {
             if (n < 3) return n;
             vector<int> dp(n);
             dp[0] = 1, dp[1] = 2;
             for (int i{2}; i < n; ++i) dp[i] = dp[i - 1] + dp[i - 2];
             return dp[n - 1];
         }
     };
     // 滚动数组
     class Solution {
     public:
         int climbStairs(int n) {
             if (n < 3) return n;
             int a{1}, b{2};
             for (int i{2}; i < n; ++i) tie(a, b) = pair(b, a + b);
             return b;
         }
     };
     // 终极优化
     class Solution {
     public:
         int climbStairs(int n) {
             if (n < 3) return n;
             int a{1}, b{2}, tmp{};
             for (int i{2}; i < n; ++i) tmp = b, b += a, a = tmp;
             return b;
         }
     };
     ```

     

4.   [746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/);[剑指 Offer II 088. 爬楼梯的最少成本 - 力扣（LeetCode）](https://leetcode.cn/problems/GzCJIP/);

     ```cpp
     class Solution {
     public:
         int minCostClimbingStairs(vector<int> &cost) {
             int n = cost.size();
             vector<int> dp(n + 1);
             for (int i{2}; i <= n; ++i)
                 dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
             return dp[n];
         }
     };
     // 滚动数组
     class Solution {
     public:
         int minCostClimbingStairs(vector<int> &cost) {
             int n = cost.size(), a{}, b{}, tmp{};
             for (int i{}; i < n - 1; ++i)
                 tmp = b, b = min(b + cost[i + 1], a + cost[i]), a = tmp;
             return b;
         }
     };
     ```

5.   [343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/);(还有$O(1)$的数学做法)


     ```cpp
     class Solution {
     public:
         int integerBreak(int n) {
             vector<int> dp(n + 1);
             dp[2] = 1;
             for (int i{3}; i <= n; ++i)
                 // 这里进行了优化, 原来是j<i, 浪费时间
                 // 优化的依据是满足最大乘积的拆分数字尽可能接近
                 for (int j{1}; j < 1 + i / 2; ++j)
                     dp[i] = max({dp[i], j * dp[i - j], j * (i - j)});
             return dp[n];
         }
     };
     ```

6.   



# 路径问题

1.   [62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/);(经典的二维DP问题)

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             vector<vector<int>> dp(m, vector<int>(n));
             for (int i{}; i < n; ++i) dp[0][i] = 1;
             for (int j{1}; j < m; ++j) dp[j][0] = 1;
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
             return dp[m - 1][n - 1];
         }
     };
     ```

     滚动数组优化:

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             vector<int> dp(n, 1);
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j) dp[j] += dp[j - 1];
             return dp[n - 1];
         }
     };
     ```

     组合数学公式方法也可以:(注意这里`ans=ans*...`是必须的, 因为如果写成`ans*=...`会导致除法舍入)

     ```cpp
     class Solution {
     public:
         int uniquePaths(int m, int n) {
             long ans{1};
             for (int i{}; i < m - 1; ++i) ans = ans * (n + i) / (i + 1);
             return ans;
         }
     };
     ```

     

2.   [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/);

     ```cpp
     class Solution {
     public:
         int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
             int m = obstacleGrid.size(), n = obstacleGrid[0].size();
             if (obstacleGrid[0][0]) return 0; // 注意初始值为障碍物, 后面不需要考虑
     
             vector<vector<int>> dp(m, vector<int>(n));
             int i{}, j{1};
             for (; i < n && obstacleGrid[0][i] != 1; ++i) dp[0][i] = 1;
             for (; j < m && obstacleGrid[j][0] != 1; ++j) dp[j][0] = 1;
             for (i = 1; i < m; ++i)
                 for (j = 1; j < n; ++j)
                     if (obstacleGrid[i][j] == 0)
                         dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
             return dp[m - 1][n - 1];
         }
     };
     ```

     同样可以滚动数组优化:(有点技巧, 参考了官方题解)

     ```cpp
     class Solution {
     public:
         int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
             int m = obstacleGrid.size(), n = obstacleGrid[0].size();
             vector<int> dp(n);
             dp[0] = obstacleGrid[0][0] != 1;
             for (int i{}; i < m; ++i)
                 for (int j{}; j < n; ++j) {
                     if (obstacleGrid[i][j]) {
                         dp[j] = 0;
                         continue;
                     }
                     if (j && obstacleGrid[i][j - 1] == 0) dp[j] += dp[j - 1];
                 }
             return dp[n - 1];
         }
     };
     ```

     

3.   [64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/);

4.   [980. 不同路径 III - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-iii/);

5.   [1824. 最少侧跳次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-sideway-jumps/);

6.   [剑指 Offer 47. 礼物的最大价值 - 力扣（LeetCode）](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/);(二维dp的经典问题, 路径求和找最大即可)

     ```cpp
     class Solution {
     public:
         int maxValue(vector<vector<int>>& grid) {
             int m = grid.size(), n = grid[0].size();
             // dp
             vector<vector<int>> dp(m, vector<int>(n));
             // init
             for (int i{}; i < n; ++i)
                 dp[0][i] += grid[0][i] + (i ? dp[0][i - 1] : 0);
     
             for (int i{1}; i < m; ++i) dp[i][0] += grid[i][0] + dp[i - 1][0];
     
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j)
                     dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
     
             return dp[m - 1][n - 1];
         }
     };
     // 使用本地数组
     class Solution {
     public:
         int maxValue(vector<vector<int>>& grid) {
             int m = grid.size(), n = grid[0].size();
             // init
             for (int i{1}; i < n; ++i) grid[0][i] += grid[0][i - 1];
             for (int i{1}; i < m; ++i) grid[i][0] += grid[i - 1][0];
     
             for (int i{1}; i < m; ++i)
                 for (int j{1}; j < n; ++j)
                     grid[i][j] = max(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
             return grid[m - 1][n - 1];
         }
     };
     ```

     





# 子序列/子数组

## 子序列

1.   [674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/);

     DP做法:

     ```cpp
     class Solution {
     public:
         int findLengthOfLCIS(vector<int>& nums) {
             int n = nums.size();
             vector<int> dp(n, 1);
             dp[0] = 1;
             for (int i{1}; i < n; ++i)
                 if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
     
             return *max_element(dp.begin(), dp.end());
         }
     };
     ```

     贪心也能做:(最优方法, 空间复杂度$O(1)$)

     ```cpp
     class Solution {
     public:
         int findLengthOfLCIS(vector<int>& nums) {
             int pre = INT_MIN, ans{}, tmp{};
             for (auto num : nums) {
                 if (num > pre)
                     tmp++;
                 else
                     ans = max(ans, tmp), tmp = 1;
                 pre = num;
             }
             return max(ans, tmp);
         }
     };
     ```

     

2.   [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/);(贪心也可以做)

     ```cpp
     class Solution {
     public:
         int lengthOfLIS(vector<int>& nums) {
             int n = nums.size();
             vector<int> dp(n, 1);
             for (int i{1}; i < n; ++i)
                 for (int j{}; j < i; ++j)
                     if (nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1);
             return *max_element(dp.begin(), dp.end());
         }
     };
     ```

3.   [354. 俄罗斯套娃信封问题 - 力扣（LeetCode）](https://leetcode.cn/problems/russian-doll-envelopes/);

     ```cpp
     
     ```

     

4.   [1691. 堆叠长方体的最大高度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/);

     ```cpp
     ```

     

5.   [1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/);[剑指 Offer II 095. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/qJnOS7/);

     ```cpp
     // 二维数组
     class Solution {
     public:
         int longestCommonSubsequence(string text1, string text2) {
             int m = text1.size(), n = text2.size();
             int dp[m + 1][n + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{1}; i <= m; ++i)
                 for (int j{1}; j <= n; ++j)
                     dp[i][j] = (text1[i - 1] == text2[j - 1])
                                    ? dp[i - 1][j - 1] + 1
                                    : max(dp[i][j - 1], dp[i - 1][j]);
             return dp[m][n];
         }
     };
     // 两个数组优化
     class Solution {
     public:
         int longestCommonSubsequence(string text1, string text2) {
             int m = text1.size(), n = text2.size();
             int dp[2][n + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{}; i < m; ++i)
                 for (int j{}; j < n; ++j)
                     dp[(i + 1) % 2][j + 1] =
                         (text1[i] == text2[j])
                             ? dp[i % 2][j] + 1
                             : max(dp[(i + 1) % 2][j], dp[i % 2][j + 1]);
             return dp[m % 2][n];
         }
     };
     // 一维数组优化
     class Solution {
     public:
         int longestCommonSubsequence(string text1, string text2) {
             int n = text2.size(), dp[n + 1];
             memset(dp, 0, sizeof(dp));
             for (char c : text1)
                 for (int j{}, pre{}; j < n; ++j) {
                     int tmp = dp[j + 1];
                     dp[j + 1] = (c == text2[j]) ? pre + 1 : max(dp[j], dp[j + 1]);
                     pre = tmp;
                 }
             return dp[n];
         }
     };
     ```

6.   [1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/);(和LCS类似, 转变一下思路, 直接拿来LCS的代码用)

     ```cpp
     class Solution {
     public:
         int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
             int n1 = nums1.size(), n2 = nums2.size();
             int dp[n1 + 1][n2 + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{1}; i <= n1; ++i) {
                 for (int j{1}; j <= n2; ++j) {
                     if (nums1[i - 1] == nums2[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     else 
                         dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                 }
             }
             return dp[n1][n2];
         }
     };
     ```

     

7.   [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/);(双指针也能做, DP普适性好, 编辑距离入门)

     ```cpp
     class Solution {
     public:
         bool isSubsequence(string s, string t) {
             int n1 = s.size(), n2 = t.size();
             int dp[n1 + 1][n2 + 1]; // [0, i], [0, j]内s与t公共的子序列长度
             memset(dp, 0, sizeof(dp));
             for (int i{1}; i <= n1; ++i) {
                 for (int j{1}; j <= n2; ++j) {
                     if (s[i - 1] == t[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     else 
                         dp[i][j] = dp[i][j - 1];
                 }
             }
             return dp[n1][n2] == n1;
         }
     };
     // 剪枝一下
     class Solution {
     public:
         bool isSubsequence(string s, string t) {
             if (s.empty()) return true; // 需要考虑空字符串情况
             int n1 = s.size(), n2 = t.size();
             int dp[n1 + 1][n2 + 1]; // [0, i], [0, j]内s(与t公共)的子序列长度
             memset(dp, 0, sizeof(dp));
             for (int j{1}; j <= n2; ++j) {
                 for (int i{1}; i <= n1; ++i) {
                     if (s[i - 1] == t[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     else
                         dp[i][j] = dp[i][j - 1];
                 }
                 if (dp[n1][j] == n1) return true;
             }
             return false;
         }
     };
     // 滚动数组
     class Solution {
     public:
         bool isSubsequence(string s, string t) {
             int n1 = s.size(), n2 = t.size();
             int dp[n2 + 1]; // [0, i], [0, j]内s与t公共的子序列长度
             memset(dp, 0, sizeof(dp));
             for (int i{1}; i <= n1; ++i) {
                 for (int j{1}, pre{}; j <= n2; ++j) {
                     int tmp{dp[j]};
                     if (s[i - 1] == t[j - 1])
                         dp[j] = pre + 1;
                     else 
                         dp[j] = dp[j - 1];
                     pre = tmp;
                 }
             }
             return dp[n2] == n1;
         }
     };
     ```

8.   [115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/);

     ```cpp
     class Solution {
     public:
         int numDistinct(string s, string t) {
             int m = s.size(), n = t.size();
             int dp[m + 1][n + 1];
             memset(dp, 0, sizeof(dp));
             for (int i{0}; i <= m; ++i) dp[i][0] = 1;
             for (int i{1}; i <= m; ++i)
                 for (int j{1}; j <= n; ++j)
                     if (s[i - 1] == t[j - 1])
                         dp[i][j] = 1ll * dp[i - 1][j - 1] + dp[i - 1][j];
                     else
                         dp[i][j] = dp[i - 1][j];
             return dp[m][n];
         }
     };
     // 优化, 减少判断
     class Solution {
     public:
         int numDistinct(string s, string t) {
             int n1 = s.size(), n2 = t.size();
             int dp[n1 + 1][n2 + 1]; // [0, i]中t取[0, j]的子序列个数
             memset(dp, 0, sizeof(dp));
             for (int i{}; i <= n1; ++i) dp[i][0] = 1;
             for (int i{1}; i <= n1; ++i)
                 for (int j{1}; j <= n2; ++j)
                     dp[i][j] = 1ll * (s[i - 1] == t[j - 1]) * dp[i - 1][j - 1] +
                                dp[i - 1][j];
     
             return dp[n1][n2];
         }
     };
     // 滚动数组
     class Solution {
     public:
         int numDistinct(string s, string t) {
             int m = s.size(), n = t.size();
             int dp[n + 1];
             memset(dp, 0, sizeof(dp));
             dp[0] = 1;
             for (int i{1}; i <= m; ++i)
                 for (int j{1}, pre{1}; j <= n; ++j) { // pre 初始化为1
                     int tmp{dp[j]};
                     dp[j] += 1ll * (s[i - 1] == t[j - 1]) * pre;
                     pre = tmp;
                 }
             return dp[n];
         }
     };
     ```

9.   [583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/);

     ```cpp
     class Solution {
     public:
         int minDistance(string s, string t) {
             int m = s.size(), n = t.size();
             int dp[m + 1][n + 1]; // 使s[0:i]和t[0:j]相同的最少删除次数
             memset(dp, 0, sizeof(dp));
             // init
             for (int i{1}; i <= m; ++i) dp[i][0] = i;
             for (int i{1}; i <= n; ++i) dp[0][i] = i;
             // calc
             for (int i{1}; i <= m; ++i)
                 for (int j{1}; j <= n; ++j) {
                     if (s[i - 1] != t[j - 1]) // 都要删
                         dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;
                     else
                         dp[i][j] = dp[i - 1][j - 1];
                 }
             return dp[m][n];
         }
     };
     // 滚动数组
     class Solution {
     public:
         int minDistance(string s, string t) {
             int m = s.size(), n = t.size(), i, j, pre, tmp;
             int dp[n + 1]; // 使s[0:i]和t[0:j]相同的最少删除次数
             memset(dp, 0, sizeof(dp));
             // init
             for (i = 1; i <= n; ++i) dp[i] = i;
             // calc
             for (i = 1; i <= m; ++i)
                 // dp[0] = i初始化一定要加
                 for (j = 1, pre = i - 1, dp[0] = i; j <= n; ++j) {
                     tmp = dp[j];
                     if (s[i - 1] != t[j - 1]) // 都要删
                         dp[j] = min(dp[j], dp[j - 1]) + 1;
                     else
                         dp[j] = pre;
                     pre = tmp;
                 }
             return dp[n];
         }
     };
     ```

     

10.   [72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/);(终极boss)

      ```cpp
      class Solution {
      public:
          int minDistance(string word1, string word2) {
              int m = word1.size(), n = word2.size();
              int dp[m + 1][n + 1];
              memset(dp, 0, sizeof(dp));
              for (int i{1}; i <= m; ++i) dp[i][0] = i;
              for (int j{1}; j <= n; ++j) dp[0][j] = j;
              for (int i{1}; i <= m; ++i)
                  for (int j{1}; j <= n; ++j)
                      if (word1[i - 1] == word2[j - 1])
                          dp[i][j] = dp[i - 1][j - 1];
                      else
                          dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
              return dp[m][n];
          }
      };
      // 一维
      class Solution {
      public:
          int minDistance(string s, string t) {
              int m = s.size(), n = t.size();
              int dp[n + 1];
              memset(dp, 0, sizeof(dp));
              // init
              for (int j{1}; j <= n; ++j) dp[j] = j;
              // calc
              for (int i{1}; i <= m; ++i) {
                  dp[0] = i;
                  for (int j{1}, pre{i - 1}; j <= n; ++j) {
                      int tmp{dp[j]};
                      if (s[i - 1] == t[j - 1])
                          dp[j] = pre;
                      else
                          dp[j] = min(dp[j - 1], min(dp[j], pre)) + 1;
                      pre = tmp;
                  }
              }
              return dp[n];
          }
      };
      ```

11.   $\bigstar$[1092. 最短公共超序列](https://leetcode.cn/problems/shortest-common-supersequence/);(难, 需要考虑从后往前遍历, 并且自己构造字符串)

      ```cpp
      class Solution {
      public:
          string shortestCommonSupersequence(string s, string t) {
              int m = s.size(), n = t.size();
              // 存长度
              int dp[m + 1][n + 1];
              memset(dp, 0, sizeof(dp));
              // init
              for (int j{1}; j <= n; ++j) dp[0][j] = j;
              for (int i{1}; i <= m; ++i) dp[i][0] = i;
              // calc
              for (int i{1}; i <= m; ++i)
                  for (int j{1}; j <= n; ++j)
                      if (s[i - 1] == t[j - 1])
                          dp[i][j] = dp[i - 1][j - 1] + 1;
                      else
                          dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;
              /* str1 = "abac", str2 = "cab"
              0   1   2   3
              1   2   2   4
              2   3   4   3
              3   4   4   5
              4   4   5   6
              */
              // for (int i{}; i <= m; ++i) {
              //     for (int j{}; j <= n; ++j)
              //         cout<< dp[i][j]<<"\t";
              //     cout<<endl;
              // }
              // 构造字符串
              string ans{};
              int i{m}, j{n};
              while (i && j) {
                  if (s[i - 1] == t[j - 1])
                      ans = s[--i] + ans, --j;
                  else if (dp[i][j] == dp[i - 1][j] + 1)
                      ans = s[--i] + ans;
                  else
                      ans = t[--j] + ans;
              }
              // 可不计s和t前面的顺序
              return t.substr(0, j) + s.substr(0, i) + ans;
          }
      };
      ```

      

12.   [1638. 统计只差一个字符的子串数目](https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/);

      ```cpp
      class Solution {
      public:
          int countSubstrings(string s, string t) {
              int m = s.size(), n = t.size(), ans{};
              int dpl[m + 1][n + 1], dpr[m + 1][n + 1];
              memset(dpl, 0, sizeof(dpl)), memset(dpr, 0, sizeof(dpr));
              // 中心扩展, 找相等字符
              for (int i{m - 1}; i >= 0; --i)
                  for (int j{n - 1}; j >= 0; --j)
                      dpr[i][j] = s[i] == t[j] ? dpr[i + 1][j + 1] + 1 : 0;
      
              for (int i{}; i < m; ++i)
                  for (int j{}; j < n; ++j)
                      if (s[i] == t[j])
                          dpl[i + 1][j + 1] = s[i] == t[j] ? dpl[i][j] + 1 : 0;
                      else
                          ans += (dpl[i][j] + 1) * (dpr[i + 1][j + 1] + 1);
      
              return ans;
          }
      };
      ```

      




## 字符串匹配问题

1.   [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/);

     ```cpp
     class Solution {
     public:
         bool isMatch(string s, string p) {
             int m = s.size(), n = p.size();
             bool dp[m + 1][n + 1];
             memset(dp, false, sizeof(dp));
             dp[0][0] = true;
     
             // 初始化第一行
             for (int j = 2; j <= n; j++) dp[0][j] = dp[0][j - 2] && p[j - 1] == '*';
     
             // 状态转移
             for (int i = 1; i <= m; i++) {
                 for (int j = 1; j <= n; j++) {
                     if (p[j - 1] != '*')
                         dp[i][j] = dp[i - 1][j - 1] &&
                                    (s[i - 1] == p[j - 1] || p[j - 1] == '.');
                     else
                         dp[i][j] = dp[i][j - 2] ||
                                    (dp[i - 1][j] &&
                                     (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
                 }
             }
     
             return dp[m][n];
         }
     };
     ```

     

2.   [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/);

     ```cpp
     class Solution {
     public:
         bool isMatch(string s, string p) {
             int m = s.size(), n = p.size();
             bool dp[m + 1][n + 1];
             memset(dp, false, sizeof(dp));
             // 初始化
             dp[0][0] = true;
             // 仅当前面全为*时候才能匹配空字符串
             for (int i{1}; i <= n && p[i - 1] == '*'; ++i) dp[0][i] = true;
     
             for (int i{1}; i <= m; ++i) {
                 for (int j{1}; j <= n; ++j) {
                     if (s[i - 1] == p[j - 1] || p[j - 1] == '?')
                         dp[i][j] = dp[i - 1][j - 1];
                     else if (p[j - 1] == '*') // 使用*: (i-1, j), 不使用*: (i, j-1)
                         dp[i][j] = dp[i][j - 1] | dp[i - 1][j];
                 }
             }
             return dp[m][n];
         }
     };
     ```
     
     

## 回文问题

>   可以不用DP, 使用双指针或者马拉车都比DP快很多. 

1.   [647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/);

     ```cpp
     class Solution {
     public:
         int countSubstrings(string s) {
             int n = s.size(), ans{};
             bool dp[n][n];
             memset(dp, false, sizeof(dp));
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i}; j < n; ++j)
                     if (s[i] == s[j])
                         if (j - i <= 1)
                             dp[i][j] = true, ans++;
                         else if (dp[i + 1][j - 1])
                             dp[i][j] = true, ans++;
             return ans;
         }
     };
     ```

     

2.   [5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/);(回文子串那个题的基础上加上更新最大值的操作即可)

     ```cpp
     class Solution {
     public:
         string longestPalindrome(string s) {
             int n = s.size(), maxL{}, st{};
             bool dp[n][n];
             memset(dp, false, sizeof(dp));
             for (int i{}; i < n; ++i) dp[i][i] = true;
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i}; j < n; ++j) {
                     if (s[i] == s[j])
                         if (j - i <= 1)
                             dp[i][j] = true;
                         else if (dp[i + 1][j - 1])
                             dp[i][j] = dp[i + 1][j - 1];
                     // 更新
                     if (dp[i][j] && j - i + 1 > maxL) maxL = j - i + 1, st = i;
                 }
             return s.substr(st, maxL);
         }
     };
     ```

     

3.   [516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/);

     ```cpp
     class Solution {
     public:
         int longestPalindromeSubseq(string s) {
             int n = s.size();
             int dp[n][n];
             memset(dp, 0, sizeof(dp));
             for (int i{n - 1}; i >= 0; --i) dp[i][i] = 1;
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i + 1}; j < n; ++j)
                     if (s[i] == s[j])
                         dp[i][j] = dp[i + 1][j - 1] + 2;
                     else
                         dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
             return dp[0][n - 1];
         }
     };
     // 滚动数组优化
     class Solution {
     public:
         int longestPalindromeSubseq(string s) {
             int n = s.size();
             int dp[n];
             memset(dp, 0, sizeof(dp));
             for (int i{}; i < n; ++i) dp[i] = 1;
             for (int i{n - 1}; i >= 0; --i)
                 for (int j{i + 1}, pre{}; j < n; ++j) {
                     int tmp{dp[j]};
                     dp[j] = (s[i] == s[j]) ? pre + 2 : max(dp[j - 1], dp[j]);
                     pre = tmp;
                 }
             return dp[n - 1];
         }
     };
     ```

     

4.   

5.   







## 子数组(连续的子序列)

1.   [718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/);

     ```cpp
     class Solution {
     public:
         int findLength(vector<int> &nums1, vector<int> &nums2) {
             int n1 = nums1.size(), n2 = nums2.size();
             vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));
             int ans{}, i{}, j{};
             for (i = 1; i <= n1; ++i)
                 for (j = 1; j <= n2; ++j) {
                     if (nums1[i - 1] == nums2[j - 1])
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                     if (dp[i][j] > ans) ans = dp[i][j];
                 }
             return ans;
         }
     };
     // 滚动数组
     class Solution {
     public:
         int findLength(vector<int> &nums1, vector<int> &nums2) {
             int n1 = nums1.size(), n2 = nums2.size();
             vector<int> dp(n2 + 1);
             int ans{}, i{}, j{};
             for (i = 1; i <= n1; ++i)
                 for (j = n2; j > 0; --j) {
                     if (nums1[i - 1] == nums2[j - 1])
                         dp[j] = dp[j - 1] + 1;
                     else
                         dp[j] = 0;
                     if (dp[j] > ans) ans = dp[j];
                 }
             return ans;
         }
     };
     ```

2.   [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)

     ```cpp
     class Solution {
     public:
         int maxSubArray(vector<int> &nums) {
             int n = nums.size();
             vector<int> dp(n);
             dp[0] = nums[0];
             for (int i{1}; i < n; ++i) dp[i] = max(nums[i], dp[i - 1] + nums[i]);
             return *max_element(dp.begin(), dp.end());
         }
     };
     // 滚动数组
     class Solution {
     public:
         int maxSubArray(vector<int> &nums) {
             int n = nums.size();
             if (n == 1) return nums[0];
             int a{nums[0]}, b{}, ans{INT_MIN};
             for (int i{1}; i < n; ++i)
                 b = max(nums[i], a + nums[i]), ans = max({a, b, ans}), a = b;
             return ans;
         }
     };
     ```

     

3.   



# 背包问题



## 0-1背包

1.   原始问题
     ```cpp
     class Solution {
     public:
         int BagMaxVAlue(vector<int>& value, vector<int>& weight, int maxWeight) {
             // 滚动数组优化
             int n = value.size();
             vector<int> dp(maxWeight + 1);
             for (int j{weight[0]}; j <= maxWeight; ++j)
                 if (weight[0] <= j) dp[j] = value[0];
             cout << dp;
             // for不可换序
             for (int i{1}; i < n; ++i) {                    // object
                 for (int j{maxWeight}; j >= weight[i]; --j) // bag-weight
                     dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
                 cout << dp;
             }
             return dp[maxWeight];
         }
         int BagMaxVAlue1(vector<int>& value, vector<int>& weight, int maxWeight) {
             // 二维DP
             int n = value.size();
             vector<vector<int>> dp(n, vector<int>(maxWeight + 1));
             for (int j{weight[0]}; j <= maxWeight; ++j)
                 if (weight[0] <= j) dp[0][j] = value[0];
             cout << dp;
             // for换序也可
             for (int j{}; j <= maxWeight; ++j) // bag-weight
                 for (int i{1}; i < n; ++i)     // object
                     if (j < weight[i])
                         dp[i][j] = dp[i - 1][j];
                     else
                         dp[i][j] =
                             max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
             cout << dp;
             return dp[n - 1][maxWeight];
         }
     };
     
     int main(int argc, char const* argv[]) {
         Solution s;
         vector<int> v{15, 20, 30}, w{1, 3, 4};
         int mw = 4;
         cout << s.BagMaxVAlue(v, w, mw) << endl;
         return 0;
     }
     
     ```

2.   [416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/);

3.   [1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/);

4.   [494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/);

5.   [474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/);





## 完全背包

1.   [322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/);
2.   [518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/);
3.   [377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/);

     ```cpp
     ```

     











# 数位DP(难, 本质上是记忆化深搜)

>   [数位 DP 通用模板，附题单（Python/Java/C++/Go） - 不含连续1的非负整数 - 力扣（LeetCode）](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/solution/by-endlesscheng-1egu/);

1.   [600. 不含连续1的非负整数 - 力扣（LeetCode）](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/);
2.   [233. 数字 1 的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-digit-one/);
3.   [面试题 17.06. 2出现的次数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-2s-in-range-lcci/);
4.   [902. 最大为 N 的数字组合 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/);
5.   [1012. 至少有 1 位重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-with-repeated-digits/);

     ```cpp
     class Solution {
     public:
         int numDupDigitsAtMostN(int n) {
             auto s = to_string(n);
             int m = s.length(), dp[m][1 << 10];
             memset(dp, -1, sizeof(dp)); // -1 表示没有计算过
             function<int(int, int, bool, bool)> f =
                 [&](int i, int mask, bool is_limit, bool is_num) -> int {
                 if (i == m) return is_num; // is_num 为 true 表示得到了一个合法数字
                 if (!is_limit && is_num && dp[i][mask] != -1) return dp[i][mask];
                 int res = 0;
                 if (!is_num) // 可以跳过当前数位
                     res = f(i + 1, mask, false, false);
                 int up = is_limit ? s[i] - '0' : 9;
                 // 如果前面填的数字都和 n 的一样，那么这一位至多填数字
                 // s[i]（否则超过 n)
                 for (int d = 1 - is_num; d <= up; ++d) // 枚举要填入的数字 d
                     if ((mask >> d & 1) == 0)          // d 不在 mask 中
                         res += f(i + 1, mask | (1 << d), is_limit && d == up, true);
                 if (!is_limit && is_num) // 如果有限制并且填过数字,
                                          // 这种情况之后不会再次出现, 所以不需要记忆
                     dp[i][mask] = res;
                 return res;
             };
             return n - f(0, 0, true, false);
         }
     };
     ```

6.   [1397. 找到所有好字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-good-strings/);
7.   

