---
tags: DSA LeetCode C++
---

# 写在前面



# 栈入门

主要用于深度优先搜索, 模拟**递归**过程, 以及一些特定解法的题目(例如单调栈, 括号匹配, 逆波兰表达式求值等), 

## 基本实现

通过C风格数组很容易实现栈, 在C++STL中也有实现(通过deque), 不过基本的栈操作还是要用数组来完成, 要了解每一个API的实现过程. 



## 基本题目

1.   [20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/);

     ```cpp
     // 💩一样的代码
     class Solution {
     public:
         bool isValid(string s) {
             if (s.size() & 1) return false;
             stack<char> st;
             for (auto c : s) {
                 if (c == '(' || c == '[' || c == '{')
                     st.push(c);
                 else if (st.empty())
                     return false;
                 else if (c == ')')
                     if (st.top() == '(')
                         st.pop();
                     else
                         return false;
                 else if (c == ']')
                     if (st.top() == '[')
                         st.pop();
                     else
                         return false;
                 else if (c == '}')
                     if (st.top() == '{')
                         st.pop();
                     else
                         return false;
             }
             return st.empty();
         }
     };
     // 官方的代码:
     class Solution {
     public:
         bool isValid(string s) {
             if (s.size() & 1) return false;
             stack<char> st;
             unordered_map<char, char> pairs{
                 {')', '('},
                 {']', '['},
                 {'}', '{'},
             };
             for (auto c : s) {
                 if (pairs.find(c) != pairs.end()) {
                     if (st.empty() || st.top() != pairs[c]) return false;
                     st.pop();
                 } else
                     st.push(c);
             }
             return st.empty();
         }
     };
     ```

2.   



# 队列入门



主要用于广度优先搜索, 以及一些需要后进先出的情况. 







# 栈进阶

## 最小栈

[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/);

STL: 用两个栈来模拟. 

```cpp
class MinStack {
    stack<int> st, minSt;

public:
    MinStack() { minSt.emplace(INT_MAX); }

    void push(int val) {
        st.emplace(val);
        minSt.emplace(min(minSt.top(), val));
    }

    void pop() {
        st.pop();
        minSt.pop();
    }

    int top() { return st.top(); }

    int getMin() { return minSt.top(); }
};
```

数组模拟:

```cpp

```

$\bigstar$单一栈实现: 通过数组差值来做: 

```cpp
class MinStack {
    stack<long> st;
    long min_val = -1, top1{}, diff{};

public:
    MinStack() {}

    void push(int val) {
        if (st.empty())
            st.emplace(0), min_val = val;
        else {
            diff = val - min_val;
            st.emplace(diff);
            min_val = diff > 0 ? min_val : val;
        }
    }

    void pop() {
        if (!st.empty()) {
            diff = st.top(), st.pop();
            if (diff < 0)
                top1 = min_val, min_val = top1 - diff;
            else
                top1 = min_val + diff;
        }
    }

    int top() { return st.top() < 0 ? min_val : st.top() + min_val; }

    int getMin() { return st.empty() ? -1 : min_val; }
};
```





## 用两个栈实现队列

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/)



## 逆波兰表达式求值

栈的经典运用了

```cpp
class Solution {
public:
    long atoi(string s) {
        long ans{};
        bool isNeg = s[0] == '-';
        for (int i = isNeg; i < s.size(); ++i) ans = 10 * ans + s[i] - '0';
        return isNeg ? -ans : ans;
    }
    int evalRPN(vector<string>& tokens) {
        int lhs{}, rhs{};
        stack<int> st;
        for (string s : tokens) {
            if (isdigit(s[0]) || s.size() > 1 && '-' == s[0])
                st.push(atoi(s));
            else if (s[0] == '+') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs + rhs);
            } else if (s[0] == '-') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs - rhs);
            } else if (s[0] == '*') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs * rhs);
            } else if (s[0] == '/') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs / rhs);
            }
        }
        return st.top();
    }
};
```

当然, 可以简化一下: (冗余代码太多了)

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        int n = tokens.size(), lhs, rhs;
        for (auto token : tokens) {
            if (isdigit(token[0]) || token.size() > 1 && token[0] == '-') {
                st.push(stoi(token));
            } else {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                switch (token[0]) {
                    case '+':
                        st.push(lhs + rhs);
                        break;
                    case '-':
                        st.push(lhs - rhs);
                        break;
                    case '*':
                        st.push(lhs * rhs);
                        break;
                    case '/':
                        st.push(lhs / rhs);
                        break;
                }
            }
        }
        return st.top();
    }
};


```

### 数组模拟栈

需要考虑数组开多大: 

考虑到一个合法的逆波兰表达式数组, 其长度一定是一个奇数(至少是3, 每次加一个操作数加一个操作符)

并且, 操作数要比操作符的数量多一个, 那么就是
$$
\begin{cases}
操作数个数:&\frac{n+1}2\\
操作符个数:&\frac{n-1}2
\end{cases}
$$
这样一来, 数组长度选取为$\frac{n+1}2$即可满足条件. 

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int n = tokens.size(), idx = -1;
        int st[(n + 1) / 2];
        for (auto token : tokens) {
            if (isdigit(token[0]) || token.size() > 1 && token[0] == '-') {
                st[++idx] = stoi(token);
            } else {
                switch (token[0]) {
                    case '+':
                        --idx;
                        st[idx] += st[idx + 1];
                        break;
                    case '-':
                        --idx;
                        st[idx] -= st[idx + 1];
                        break;
                    case '*':
                        --idx;
                        st[idx] *= st[idx + 1];
                        break;
                    case '/':
                        --idx;
                        st[idx] /= st[idx + 1];
                        break;
                }
            }
        }
        return st[idx];
    }
};

```




### 递归解法

递归魔法, 相当于反着遍历

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int idx = tokens.size() - 1;
        function<int()> f = [&]() {
            if (tokens[idx].size() == 1 && !isdigit(tokens[idx][0])) {
                char op = tokens[idx--][0];
                int rhs = f(), lhs = f(), ans{};
                switch (op) {
                    case '+':
                        ans = lhs + rhs;
                        break;
                    case '-':
                        ans = lhs - rhs;
                        break;
                    case '*':
                        ans = lhs * rhs;
                        break;
                    default:
                        ans = lhs / rhs;
                }
                return ans;
            }
            return stoi(tokens[idx--]);
        };
        return f();
    }
};
```







# 队列进阶



## 用两个队列实现栈

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/);



## 循环队列

[622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/);



## 循环双端队列



[641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/);

```cpp
```





# 单调栈

## 入门级

1.   [496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/);(基本的单调栈题目)
2.   [503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/);(循环数组)
3.   [907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/);
4.   [2104. 子数组范围和  - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-ranges/);(可暴力)



## 进阶级

1.   [962. 最大宽度坡 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-width-ramp/);(单调栈求最长)
2.   [1124. 表现良好的最长时间段 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-well-performing-interval/);(上一个题的变式, 使用哈希更快, 而单调栈更普适)









# 优先队列



1.   [1792. 最大平均通过率 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-average-pass-ratio/);(需要了解到增量的递减性, 不错的优先队列题目)

2.   [剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/);[295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/);

     ```cpp
     class MedianFinder {
         priority_queue<int, vector<int>> queMin; // 大根堆
         //(堆顶元素是小于等于中位数的最大值)
         priority_queue<int, vector<int>, greater<int>> queMax; // 大于中位数的最小值
     public:
         MedianFinder() {}
     
         void addNum(int num) {
             if (queMin.empty() || num <= queMin.top()) {
                 queMin.emplace(num);
                 // 调整(满足中位数性质)
                 if (queMax.size() + 1 < queMin.size())
                     queMax.emplace(queMin.top()), queMin.pop();
             } else {
                 queMax.emplace(num);
                 if (queMin.size() < queMax.size())
                     queMin.emplace(queMax.top()), queMax.pop();
             }
         }
     
         double findMedian() {
             if (queMin.size() > queMax.size()) return queMin.top();
             return (queMin.top() + queMax.top()) / 2.0;
         }
     };
     ```

     
