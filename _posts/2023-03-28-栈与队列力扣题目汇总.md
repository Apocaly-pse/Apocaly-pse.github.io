---
tags: DSA LeetCode C++
---

# å†™åœ¨å‰é¢



# æ ˆå…¥é—¨

ä¸»è¦ç”¨äºæ·±åº¦ä¼˜å…ˆæœç´¢, æ¨¡æ‹Ÿ**é€’å½’**è¿‡ç¨‹, ä»¥åŠä¸€äº›ç‰¹å®šè§£æ³•çš„é¢˜ç›®(ä¾‹å¦‚å•è°ƒæ ˆ, æ‹¬å·åŒ¹é…, é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ç­‰), 

## åŸºæœ¬å®ç°

é€šè¿‡Cé£æ ¼æ•°ç»„å¾ˆå®¹æ˜“å®ç°æ ˆ, åœ¨C++STLä¸­ä¹Ÿæœ‰å®ç°(é€šè¿‡deque), ä¸è¿‡åŸºæœ¬çš„æ ˆæ“ä½œè¿˜æ˜¯è¦ç”¨æ•°ç»„æ¥å®Œæˆ, è¦äº†è§£æ¯ä¸€ä¸ªAPIçš„å®ç°è¿‡ç¨‹. 



## åŸºæœ¬é¢˜ç›®

1.   [20. æœ‰æ•ˆçš„æ‹¬å· - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/valid-parentheses/);

     ```cpp
     // ğŸ’©ä¸€æ ·çš„ä»£ç 
     class Solution {
     public:
         bool isValid(string s) {
             if (s.size() & 1) return false;
             stack<char> st;
             for (auto c : s) {
                 if (c == '(' || c == '[' || c == '{')
                     st.push(c);
                 else if (st.empty())
                     return false;
                 else if (c == ')')
                     if (st.top() == '(')
                         st.pop();
                     else
                         return false;
                 else if (c == ']')
                     if (st.top() == '[')
                         st.pop();
                     else
                         return false;
                 else if (c == '}')
                     if (st.top() == '{')
                         st.pop();
                     else
                         return false;
             }
             return st.empty();
         }
     };
     // å®˜æ–¹çš„ä»£ç :
     class Solution {
     public:
         bool isValid(string s) {
             if (s.size() & 1) return false;
             stack<char> st;
             unordered_map<char, char> pairs{
                 {')', '('},
                 {']', '['},
                 {'}', '{'},
             };
             for (auto c : s) {
                 if (pairs.find(c) != pairs.end()) {
                     if (st.empty() || st.top() != pairs[c]) return false;
                     st.pop();
                 } else
                     st.push(c);
             }
             return st.empty();
         }
     };
     ```

2.   



# é˜Ÿåˆ—å…¥é—¨



ä¸»è¦ç”¨äºå¹¿åº¦ä¼˜å…ˆæœç´¢, ä»¥åŠä¸€äº›éœ€è¦åè¿›å…ˆå‡ºçš„æƒ…å†µ. 







# æ ˆè¿›é˜¶

## æœ€å°æ ˆ

[155. æœ€å°æ ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/min-stack/);

STL: ç”¨ä¸¤ä¸ªæ ˆæ¥æ¨¡æ‹Ÿ. 

```cpp
class MinStack {
    stack<int> st, minSt;

public:
    MinStack() { minSt.emplace(INT_MAX); }

    void push(int val) {
        st.emplace(val);
        minSt.emplace(min(minSt.top(), val));
    }

    void pop() {
        st.pop();
        minSt.pop();
    }

    int top() { return st.top(); }

    int getMin() { return minSt.top(); }
};
```

æ•°ç»„æ¨¡æ‹Ÿ:

```cpp

```

$\bigstar$å•ä¸€æ ˆå®ç°: é€šè¿‡æ•°ç»„å·®å€¼æ¥åš: 

```cpp
class MinStack {
    stack<long> st;
    long min_val = -1, top1{}, diff{};

public:
    MinStack() {}

    void push(int val) {
        if (st.empty())
            st.emplace(0), min_val = val;
        else {
            diff = val - min_val;
            st.emplace(diff);
            min_val = diff > 0 ? min_val : val;
        }
    }

    void pop() {
        if (!st.empty()) {
            diff = st.top(), st.pop();
            if (diff < 0)
                top1 = min_val, min_val = top1 - diff;
            else
                top1 = min_val + diff;
        }
    }

    int top() { return st.top() < 0 ? min_val : st.top() + min_val; }

    int getMin() { return st.empty() ? -1 : min_val; }
};
```





## ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—

[232. ç”¨æ ˆå®ç°é˜Ÿåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-queue-using-stacks/)



## é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼

æ ˆçš„ç»å…¸è¿ç”¨äº†

```cpp
class Solution {
public:
    long atoi(string s) {
        long ans{};
        bool isNeg = s[0] == '-';
        for (int i = isNeg; i < s.size(); ++i) ans = 10 * ans + s[i] - '0';
        return isNeg ? -ans : ans;
    }
    int evalRPN(vector<string>& tokens) {
        int lhs{}, rhs{};
        stack<int> st;
        for (string s : tokens) {
            if (isdigit(s[0]) || s.size() > 1 && '-' == s[0])
                st.push(atoi(s));
            else if (s[0] == '+') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs + rhs);
            } else if (s[0] == '-') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs - rhs);
            } else if (s[0] == '*') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs * rhs);
            } else if (s[0] == '/') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs / rhs);
            }
        }
        return st.top();
    }
};
```

å½“ç„¶, å¯ä»¥ç®€åŒ–ä¸€ä¸‹: (å†—ä½™ä»£ç å¤ªå¤šäº†)

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        int n = tokens.size(), lhs, rhs;
        for (auto token : tokens) {
            if (isdigit(token[0]) || token.size() > 1 && token[0] == '-') {
                st.push(stoi(token));
            } else {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                switch (token[0]) {
                    case '+':
                        st.push(lhs + rhs);
                        break;
                    case '-':
                        st.push(lhs - rhs);
                        break;
                    case '*':
                        st.push(lhs * rhs);
                        break;
                    case '/':
                        st.push(lhs / rhs);
                        break;
                }
            }
        }
        return st.top();
    }
};


```

### æ•°ç»„æ¨¡æ‹Ÿæ ˆ

éœ€è¦è€ƒè™‘æ•°ç»„å¼€å¤šå¤§: 

è€ƒè™‘åˆ°ä¸€ä¸ªåˆæ³•çš„é€†æ³¢å…°è¡¨è¾¾å¼æ•°ç»„, å…¶é•¿åº¦ä¸€å®šæ˜¯ä¸€ä¸ªå¥‡æ•°(è‡³å°‘æ˜¯3, æ¯æ¬¡åŠ ä¸€ä¸ªæ“ä½œæ•°åŠ ä¸€ä¸ªæ“ä½œç¬¦)

å¹¶ä¸”, æ“ä½œæ•°è¦æ¯”æ“ä½œç¬¦çš„æ•°é‡å¤šä¸€ä¸ª, é‚£ä¹ˆå°±æ˜¯
$$
\begin{cases}
æ“ä½œæ•°ä¸ªæ•°:&\frac{n+1}2\\
æ“ä½œç¬¦ä¸ªæ•°:&\frac{n-1}2
\end{cases}
$$
è¿™æ ·ä¸€æ¥, æ•°ç»„é•¿åº¦é€‰å–ä¸º$\frac{n+1}2$å³å¯æ»¡è¶³æ¡ä»¶. 

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int n = tokens.size(), idx = -1;
        int st[(n + 1) / 2];
        for (auto token : tokens) {
            if (isdigit(token[0]) || token.size() > 1 && token[0] == '-') {
                st[++idx] = stoi(token);
            } else {
                switch (token[0]) {
                    case '+':
                        --idx;
                        st[idx] += st[idx + 1];
                        break;
                    case '-':
                        --idx;
                        st[idx] -= st[idx + 1];
                        break;
                    case '*':
                        --idx;
                        st[idx] *= st[idx + 1];
                        break;
                    case '/':
                        --idx;
                        st[idx] /= st[idx + 1];
                        break;
                }
            }
        }
        return st[idx];
    }
};

```




### é€’å½’è§£æ³•

é€’å½’é­”æ³•, ç›¸å½“äºåç€éå†

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int idx = tokens.size() - 1;
        function<int()> f = [&]() {
            if (tokens[idx].size() == 1 && !isdigit(tokens[idx][0])) {
                char op = tokens[idx--][0];
                int rhs = f(), lhs = f(), ans{};
                switch (op) {
                    case '+':
                        ans = lhs + rhs;
                        break;
                    case '-':
                        ans = lhs - rhs;
                        break;
                    case '*':
                        ans = lhs * rhs;
                        break;
                    default:
                        ans = lhs / rhs;
                }
                return ans;
            }
            return stoi(tokens[idx--]);
        };
        return f();
    }
};
```







# é˜Ÿåˆ—è¿›é˜¶



## ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°æ ˆ

[225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-stack-using-queues/);



## å¾ªç¯é˜Ÿåˆ—

[622. è®¾è®¡å¾ªç¯é˜Ÿåˆ—](https://leetcode.cn/problems/design-circular-queue/);



## å¾ªç¯åŒç«¯é˜Ÿåˆ—



[641. è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ—](https://leetcode.cn/problems/design-circular-deque/);

```cpp
```





# å•è°ƒæ ˆ

## å…¥é—¨çº§

1.   [496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/next-greater-element-i/);(åŸºæœ¬çš„å•è°ƒæ ˆé¢˜ç›®)
2.   [503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/next-greater-element-ii/);(å¾ªç¯æ•°ç»„)
3.   [907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-subarray-minimums/);
4.   [2104. å­æ•°ç»„èŒƒå›´å’Œ  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-subarray-ranges/);(å¯æš´åŠ›)



## è¿›é˜¶çº§

1.   [962. æœ€å¤§å®½åº¦å¡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-width-ramp/);(å•è°ƒæ ˆæ±‚æœ€é•¿)
2.   [1124. è¡¨ç°è‰¯å¥½çš„æœ€é•¿æ—¶é—´æ®µ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-well-performing-interval/);(ä¸Šä¸€ä¸ªé¢˜çš„å˜å¼, ä½¿ç”¨å“ˆå¸Œæ›´å¿«, è€Œå•è°ƒæ ˆæ›´æ™®é€‚)









# ä¼˜å…ˆé˜Ÿåˆ—



1.   [1792. æœ€å¤§å¹³å‡é€šè¿‡ç‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-average-pass-ratio/);(éœ€è¦äº†è§£åˆ°å¢é‡çš„é€’å‡æ€§, ä¸é”™çš„ä¼˜å…ˆé˜Ÿåˆ—é¢˜ç›®)

2.   [å‰‘æŒ‡ Offer 41. æ•°æ®æµä¸­çš„ä¸­ä½æ•°](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/);[295. æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode.cn/problems/find-median-from-data-stream/);

     ```cpp
     class MedianFinder {
         priority_queue<int, vector<int>> queMin; // å¤§æ ¹å †
         //(å †é¡¶å…ƒç´ æ˜¯å°äºç­‰äºä¸­ä½æ•°çš„æœ€å¤§å€¼)
         priority_queue<int, vector<int>, greater<int>> queMax; // å¤§äºä¸­ä½æ•°çš„æœ€å°å€¼
     public:
         MedianFinder() {}
     
         void addNum(int num) {
             if (queMin.empty() || num <= queMin.top()) {
                 queMin.emplace(num);
                 // è°ƒæ•´(æ»¡è¶³ä¸­ä½æ•°æ€§è´¨)
                 if (queMax.size() + 1 < queMin.size())
                     queMax.emplace(queMin.top()), queMin.pop();
             } else {
                 queMax.emplace(num);
                 if (queMin.size() < queMax.size())
                     queMin.emplace(queMax.top()), queMax.pop();
             }
         }
     
         double findMedian() {
             if (queMin.size() > queMax.size()) return queMin.top();
             return (queMin.top() + queMax.top()) / 2.0;
         }
     };
     ```

     
