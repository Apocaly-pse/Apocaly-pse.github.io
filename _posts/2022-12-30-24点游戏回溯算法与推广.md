---
tags: DSA LeetCode C/C++ Python
---

# 写在前面

前阶段LeetCode出了一个很棒的活动, 叫做1024游戏, 就是通过综合数字卡和符号卡来得到1024这个数字, 符号可以是十进制运算符号或者位运算符号, 这就不得不让我想起来24点游戏, 就是通过加减乘除加括号的方式构造24这个数字, 其中蕴含的思路都是一样的, 在算法实现中, 要用到回溯的方法, 其实就是深度优先搜索, 不满足条件的话就返回中节点继续找, 下面来看一下具体思路. 

>   [679. 24 点游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/24-game/);

# 思路

解法上有点像N皇后问题, 需要进行两层循环遍历找满足条件的解, 相当于遍历二叉树的层, 然后递归回溯, 相当于向树的叶子结点方向遍历. 

比较麻烦的点是符号的计算, 这里可以通过`Switch-case`语句来做, 然后就是三个步骤

1.   递归跳出条件: 列表中只剩下一个数, 且这个数为24(最终结果), 由于存在实数除法, 实现时候要通过与24作差绝对值小于某eps来判断
2.   循环(层遍历): 先枚举左操作数和右操作数, 然后遍历符号, 这里虽然有加减乘除, 但是减和除可以有两种可能, 这就导致了运算符遍历时候会有6种可能, 然后将每次计算的结果添加到card(实际使用临时变量列表)之后, 完成计算之后递归. 
3.   回溯, 进行`pop()`操作. 

这里给出之前写的Python代码:(配合注释还是比较好理解的)

```python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        def calc(op, lhs, rhs):
            match op:
                case 0:
                    return lhs+rhs
                case 1:
                    return lhs-rhs
                case 2:
                    return rhs-lhs
                case 3:
                    return lhs*rhs
                case 4:  # 判断被除数不为零
                    return rhs and lhs/rhs
                case _:
                    return lhs and rhs/lhs
        
        def bt(tmp):
            if (n:=len(tmp))==1:return abs(24-tmp[0])<1e-4
            for i in range(n-1):#遍历左操作数
                for j in range(i+1,n):#遍历右操作数
                    restmp=[]#存剩余的数
                    for k in range(n):
                        if k==j or k==i:continue
                        # 如果两个数未被取过, 添加到剩余的数列表中
                        restmp.append(tmp[k])
                    for op in range(6):#遍历操作符
                        # 计算中间结果并存入剩余的数列表等待下一次计算
                        restmp.append(calc(op, tmp[i], tmp[j]))
                        # 如果回溯结果为真返回
                        if bt(restmp): return True
                        # 去掉中间结果, 重新找新的两个数计算
                        restmp.pop()
            return False
        return bt(cards)
```

当然还有C++代码:(由于Switch-case需要添加break, 冗杂, 这里就直接用if-else了)

```cpp
class Solution {
public:
    bool judgePoint24(vector<int>& nums) {
        vector<double> digits;
        for (int num : nums)  digits.emplace_back(num); 
        return bt(digits);
    }

    bool bt(vector<double>& digits) {
        int n = digits.size();
        if (n == 1) { return abs(digits[0] - 24) < 0.001; }

        for (int i = 0; i < n - 1; ++i) {
            for (int j = i + 1; j < n; ++j) {
                vector<double> newDigits;
                for (int k = 0; k < n; ++k) {
                    if (k == i || k == j) continue;
                    newDigits.emplace_back(digits[k]);
                }

                for (int op = 0; op < 6; ++op) {
                    newDigits.emplace_back(calc(op, digits[i], digits[j]));
                    if (bt(newDigits)) return true;
                    newDigits.pop_back();
                }
            }
        }
        return false;
    }

    double calc(int op, double a, double b) {
        if (op == 0)
            return a + b;
        else if (op == 1)
            return a - b;
        else if (op == 2)
            return b - a;
        else if (op == 3)
            return a * b;
        else if (op == 4)
            return a / b;
        return b / a;
    }
};
```

# 推广

有了上面的思路, 其实就不难将算法推广到任意个运算符和任意数字的匹配了. 



```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <algorithm>
 
using namespace std;
 
const int TARGET = 1000;
const int N = 8;
struct item
{
    string cal;
    int num;
    bool flag;
};
item a[N];
void swap(int i,int j)
{
    item t;t=a[i];a[i]=a[j];a[j]=t;
}
map<string,bool> mhash;
char buf[10];
 
bool push_map_check(int dep)
{
    string s = "";
    for(int i=0 ; i<dep ; i++)
    {
        itoa(a[i].num,buf,10);
        s = s + buf +',';
    }
    if(mhash[s] !=true )
    {
        mhash[s] = true;
        return true;
    }
    else
    {
        return false;
    }
}
 
void search_ans(int dep)
{
    if(dep == 1 && a[0].num==TARGET)
        cout << a[0].cal << endl;
    if(dep > 1 && push_map_check(dep))
    {
        //组合i,j
        map<int ,int> hash;
        hash.clear();
        for(int i=0 ; i<dep ; i++)
            for(int j=i+1 ; j<dep ; j++)
            {
                if(hash[a[i].num] == a[j].num) continue;
                if(hash[a[j].num] == a[i].num) continue;
                hash[a[i].num] = a[j].num;
 
                swap(j,dep-1);
                item temp = a[i];
                //+
                a[i].num = a[i].num + a[dep-1].num;
                a[i].flag = false;
                a[i].cal = '(' + temp.cal + '+' + a[dep-1].cal + ')';
                search_ans(dep-1);
                a[i] = temp;
                //-
                a[i].num = a[i].num - a[dep-1].num;
                a[i].flag = false;
                a[i].cal = '(' + temp.cal + '-' + a[dep-1].cal + ')';
                search_ans(dep-1);
                a[i] = temp;
                //*
                a[i].num = a[i].num * a[dep-1].num;
                a[i].flag = false;
                a[i].cal = '(' + temp.cal + '*' + a[dep-1].cal + ')';
                search_ans(dep-1);
                a[i] = temp;
                // /
                if(a[dep-1].num !=0 && a[i].num % a[dep-1].num == 0)
                {
                    a[i].num = a[i].num / a[dep-1].num;
                    a[i].flag = false;
                    a[i].cal = '(' + temp.cal + '/' + a[dep-1].cal + ')';
                    search_ans(dep-1);
                    a[i] = temp;
                }
 
                if(a[i].flag && a[dep-1].flag && a[dep-1].num == 8)
                {
                    a[i].num = a[i].num * 10 + a[dep-1].num;
                    a[i].cal = temp.cal + a[dep-1].cal;
                    search_ans(dep-1);
                    a[i] = temp;
                }
                swap(dep-1,j);
            }
    }
}
 
 
int main()
{
    //freopen("out.txt","w",stdout);
    mhash.clear();
    for(int i=0 ;i<N ; i++ )
    {
        a[i].cal = "8";
        a[i].num = 8;
        a[i].flag = true;
    }
    search_ans(N);
	return 0;
 
}
```

