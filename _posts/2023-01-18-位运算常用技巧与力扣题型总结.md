---
tags: Mathematics DSA C++
---



# 写在前面

最近刷LeetCode, 发现很多双百题解中用到的都是位运算技巧, 下面来总结一下位运算的常用技巧. 一开始参考了知乎的一篇回答, 里面推荐一本书叫做*算法心得*, 英文原版为*Hackers Delight*, 听这个名字就知道是一些hack技巧, 有机会一定要研读一下. 下面的代码用C++给出. 



# 预备知识

首先给出一些预备知识, 包括如何进制转换等.

## 任意进制到十进制

```cpp
// 直观的想法
int x2dec_v1(string x, int k) {
    int ans{}, n = x.size();
    for (int i{}; i < n; ++i)
        ans += (x[n - 1 - i] - 48) * pow(k, i); // with cmath
    return ans;
}

// 或者更简洁的方法:
int x2dec_v2(string x, int k) {
    int ans{};
    for (char& c : x) ans = ans * k + (c - 48);
    return ans;
}
```



## 十进制到任意进制

下面的都是针对$\leqslant10$进制而言的, 对于16进制, 需要特殊处理. 

C++版本: 

```cpp
string dec2x(int x, int k) {
    string ans{};
    while (x) ans = to_string(x % k) + ans, x /= k;
    return ans;
}
```

对于十六进制:

[405. 数字转换为十六进制数 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-a-number-to-hexadecimal/);

```cpp
class Solution {
public:
    string toHex(long num) {
        string ans{};
        if (num < 0) num += (1l << 32);
        while (num) {
            auto res = num % 16;
            res += res > 9 ? 87 : 48;
            ans = static_cast<char>(res) + ans, num /= 16;
        }
        return ans.empty() ? "0" : ans;
    }
};
```

或者通过`unsigned`去掉负数的影响

```cpp
class Solution {
public:
    string toHex(unsigned num) {
        string ans{};
        while (num) {
            auto res = num % 16;
            res += res > 9 ? 87 : 48;
            ans = static_cast<char>(res) + ans, num /= 16;
        }
        return ans.empty() ? "0" : ans;
    }
};
```

分组操作, 更加麻烦的位运算: (值得学习, 因为没有更改形参类型)

```cpp
class Solution {
public:
    string toHex(int num) {
        string ans{};
        for (int i = 7; i >= 0; i--) {
            int val = (num >> (4 * i)) & 0xf;
            if (ans.size() > 0 || val > 0)
                val += val > 9 ? 87 : 48, ans += static_cast<char>(val);
        }
        return ans.empty() ? "0" : ans;
    }
};
```

二进制的情况还有一种更优的方法, 如下:

>   [用位运算实现十进制转换为二进制 - Maples7 - 博客园 (cnblogs.com)](https://www.cnblogs.com/maples7/p/4324844.html);

```cpp
string dec2bin(int x) {
    string ans{};
    for (int j = 31; j >= 0; --j) ans += x & (1 << j) ? "1" : "0";
    return ans;
}
// 不显示前导零
string dec2bin(int x) {
    string ans{};
    int tmp{};
    for (int j = 31; j >= 0; --j)
        if ((tmp = x & (1 << j)) || !ans.empty()) ans += tmp ? "1" : "0";
    return ans;
}
```





下面就是正菜了

# 位运算操作符

这里以C++为例. 

>   有的语言可能有一些区别, 例如Java/JavaScript中的左移位还分为有符号(算术移位)和无符号(逻辑移位)的情况, 包括了三种移位操作. 

| 运算名称 | 符号 |           运算规则           |
| :------: | :--: | :--------------------------: |
|    与    | `&`  | `0&0=0  0&1=0  1&0=0  1&1=1` |
|    或    | `|`  | `0|0=0  0|1=1  1|0=1  1|1=1` |
|    非    | `~`  |         `~0=1 ~1=0`          |
|   异或   | `^`  | `0^0=0  0^1=1  1^0=1  1^1=0` |
|  左移位  | `<<` |       `0001<<1 = 0010`       |
|  右移位  | `>>` |       `1000>>1 = 0100`       |



## 优先级

这里要注意一点, **位运算符的优先级要低于比较运算符**, 所以位运算最好带上括号, 否则会有意想不到的问题. 下面的运算符优先级表是cppreference[^1]中的. 

![截屏2022-12-09 10.50.44](https://s2.loli.net/2022/12/09/hZxOY1lkN4WmjsQ.jpg)



一个很坑的点就是C语言用与运算判断数字的奇偶性, 奇数的话当然没问题:

```c
#include <stdio.h>

int main(int argc, char const *argv[]) {
    int n = 11;
    if (n & 1) printf("n is odd\n");
    return 0;
}
```

但是当你加上了一个`==0`, 情况就发生了变化:

```c
#include <stdio.h>

int main(int argc, char const *argv[]) {
    int n = 10;
    if (n & 1 == 0) printf("n is even\n");
    return 0;
}
```

10难道不是偶数了? 问题就出在了`==`和`&`的优先级上面, `==`优先级高, 所以会先计算`1==0`, 得到了`false`之后隐式类型转换为`0`, 这时候`10&0`肯定就是0了, 才会出现10不是偶数这种错误. 

>   写位运算一定要注意判断语句, 总之就是, 有位运算最好还是都带上括号, 保险. 





# 异或

因为很多题目都主要用到了异或运算, 这里就先谈谈异或. 

## 基本性质

-   `a^b=(a&~b)|(b&~a)`;
-   `a^a=0`;
-   `a^0=0^a=a`;
-   `t=x^y`$\iff$`x^t=x^x^y=y`$\iff$`y^t=y^x^y=y^y^x=x`;



## 判断两数相乘/除的符号

这里分别针对每一个数进行符号判断当然可以, 但是这里用异或的话一行就可以解决:

```cpp
int a = 10, b = -12;
int sign = (a > 0) ^ (b > 0);
int ans = abs(a) * abs(b) * sign ? -1 : 1;
```



## 奇偶数的性质

1.   加一减一:
     -   `x`为奇数时: `x-1=x^1`;
     -   `x`为偶数时: `x+1=x^1`;

## 交换两个数

交换两个数应该是最经典也是最基础的一种算法了, 下面是异或实现, 不使用临时变量:

```cpp
void swap(int a, int b){
    a ^= b; // 此时a=a^b,b=b
    b ^= a; // 此时a=a^b,b=b^a^b=a
    a ^= b; // 此时a=a^b^a=b,b=a
}
```

或者利用C/C++的连等写法:

```cpp
void swap(int &a, int &b) { a ^= b ^= a ^= b; }
```

比较骚的方法. 

## 找不同(数或字符串)

利用异或运算的性质, 遍历一次数组就可以找到结果了(如果是有序数组还可以通过二分来做降低时间复杂度)

例如对于力扣的[面试题 17.04. 消失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number-lcci/);

用位运算来做简直完美:(求和也可以)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int ans{};
        for (int num : nums) ans ^= num;
        for (int i = 0; i <= nums.size(); ++i) ans ^= i;
        return ans;
    }
};
```

类似还有[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/);

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans{};
        for(int num : nums) ans ^= num;
        return ans;
    }
};
```



# 与

## 判断奇偶

```cpp
bool isOdd(int n) { return (n & 1) == 1; }
```



## 位1的个数(消除最末位)

对于一个二进制串`1011001`(89), 其中含有的`1`的个数有多少呢? 一个直观的思路当然是遍历取出, 直接模拟, 例如像下面这样:

[191. 位1的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-1-bits/);

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ans{};
        while (n) ans += (n & 1), n >>= 1;
        return ans;
    }
};
```

一些常用的技巧

```cpp
x & (x - 1) //清除最右边的1
x & -x //得到最右边的1(lsb, 最低有效位)

```

## 判断2的幂(数的二进制表示是否仅有一位)

### 方法1

```cpp
bool isPow2(int n) { return (n & (n - 1)) == 0; }
```

对于一个二进制数, 例如`10`, 其二进制表示为`1010`, `10-1=9`的二进制表示为`1001`, 两者做与运算得到`1000`即`=8!=0`, 但是对于`0100`(4), 其与`3`(`0011`)做与运算就是`0`, 这是因为对任意一个数`x`, 其减去`1`之后得到的二进制数需要从二进制表示的`从低位到高位`中最近的一个`1`借位, 使该借位的`1`后面的所有`0`都变成`1`, 那么如果这个数`x`仅有一个位`1`的话, 就可得出`x&x-1=0`了, 反之, 如果数`x`的二进制表示中不只有一个`1`, 那么减一操作只会借走最低位的`1`, 而其他剩下的`1`就不会变成`0`, 导致与运算之后结果不为`0`了.

而一个数字是不是`2`的幂, 只需要看其二进制表示中是不是只有一个位为`1`, 于是就可以通过`x&x-1==0`来判断了.

### 方法2

```cpp
bool isPow2(int n) { return (n & (-n)) == n; }
```

同样地, 我们来分析上面这个式子



## 找出某数的某一个二进制位

```cpp
// 获取 a 的第 b 位，最低位编号为 0
int getBit(int a, int b) { return (a >> b) & 1; }
```

这个和下面的一个技巧都是数位DP中比较常用的设置mask掩码的技巧, 希望大家熟练掌握. 

# 或

## 某一位设置为1

>   在数位DP, 状态压缩中常用

```cpp
// 将 a 的第 b 位设置为 1 ，最低位编号为 0
void setBit(int& a, int b) { a | (1 << b); }
```

[1832. 判断句子是否为全字母句 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-the-sentence-is-pangram/);

这个题当然可以直接哈希完事, 但是需要消耗空间, 这里就通过一个`26`位的带符号整数(称为mask, 掩码)来完成. 





# 综合运用

## 用位运算模拟两数相加(异或)

[剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/);

这里要用到异或运算的知识, 以及整数补码和溢出情况的分析. 

```cpp
class Solution {
public:
    int add(int a, int b) {
        if (b == 0) return a;
        if (a == 0) return b;
        int carry{}, ans{};
        while (b) {
            carry = (unsigned)(a & b) << 1;
            a ^= b; // a加到不进位位置
            b = carry;
        }
        return a;
    }
};
```

## 只出现一次的数字系列

1.   


# ref

[^1]:[C++ Operator Precedence - cppreference.com](https://en.cppreference.com/w/cpp/language/operator_precedence);
