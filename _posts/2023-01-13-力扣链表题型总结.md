---
tags: DSA LeetCode C++
---



1.   [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/);

     ```cpp
     ```

     
2.   [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/);

     ```cpp
     /**
      * Definition for singly-linked list.
      * struct ListNode {
      *     int val;
      *     ListNode *next;
      *     ListNode() : val(0), next(nullptr) {}
      *     ListNode(int x) : val(x), next(nullptr) {}
      *     ListNode(int x, ListNode *next) : val(x), next(next) {}
      * };
      */
     class Solution {
     public:
         ListNode* reverseList(ListNode* head) {
             ListNode* cur=head, *pre=nullptr;
             while (cur) {
                 auto tmp=cur->next;
                 cur->next=pre;
                 pre=cur;
                 cur=tmp;
             }
             return pre;
         }
     };
     ```
3.   [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/);

     ```cpp
     /**
      * Definition for singly-linked list.
      * struct ListNode {
      *     int val;
      *     ListNode *next;
      *     ListNode() : val(0), next(nullptr) {}
      *     ListNode(int x) : val(x), next(nullptr) {}
      *     ListNode(int x, ListNode *next) : val(x), next(next) {}
      * };
      */
     class Solution {
     public:
         ListNode* removeNthFromEnd(ListNode* head, int n) {
             ListNode* dummy=new ListNode(0, head);
             auto first=dummy,second=dummy;
             while(n--)first=first->next;
             while(first && first->next){
                 first=first->next;
                 second=second->next;
             }
             second->next=second->next->next;
             return dummy->next;
         }
     };
     ```
4.   [2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/);

     ```cpp
     ```

     
5.   [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/);

     ```cpp
     /**
      * Definition for singly-linked list.
      * struct ListNode {
      *     int val;
      *     ListNode *next;
      *     ListNode(int x) : val(x), next(NULL) {}
      * };
      */
     class Solution {
     public:
         bool hasCycle(ListNode *head) {
             auto f=head,l=head;
             while (1){
                 if (!f||!f->next)return false;
                 f=f->next->next;
                 l=l->next;
                 if (f==l)return true;
             }
         }
     };
     ```
7.   [1206. 设计跳表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-skiplist/);
8.   