# 写在前面

这次介绍一些树和二分图的定义和主要性质, 以及这两种结构中常用的算法, 包括二分图的判定, 最小生成树的寻找等. 



# 基本概念

-   无圈图(acyclic graph): 任何子图都不是圈的图.
-   树(tree): **连通**的**无圈**图. 
-   森林(forest): 指所有**连通分量都是树**的图. 
-   二叉树(): 一棵有根树, 其每个结点至多有两个孩子. 
-   完全二叉树: 除叶子结点外的其他所有节点都有两个孩子的有根二叉树. 
-   叶结点: 度为1的结点(一称端节点, 移除端节点之后原图仍是树).
-   桥(bridge): 一个连通图若删除某条贬值后变为非连通的, 被删除的边称为桥. 

---

-   二部图: 图$G$的结点集$V(G)$可以分为两个非空子集$V_1$和$V_2$, 且满足$G$的边$xy$关联的两个结点$x,\,y$分别属于这两个子集. (所有的树都是二分图)

-   二分图的分类:
    $$
    \begin{cases}
    |V_1|=|V_2|&:\ \text{平衡二部图}\\
    |V_1|-|V_2|=1&:\text{准平衡二部图}\\
    |V_1|-|V_2|\geq2&:\text{偏斜二分图}
    \end{cases}
    $$

-   



# 树的重要性质

-   每个非平凡树(平凡图$K_1$也是树)至少有两个端节点(叶子结点). 
-   删除树的任意一条边(即: 桥)都会使树变为非连通图. (对于费连通图来说, 删除某边如果增加连通分量数量, 这条边也称为图的桥)
-   对树的任意给定的两个节点$x, \,y$, 树中存在唯一一条路$x-y$, 因此, 此路为测地线.
-   有$n$个结点的树, 其必有$n-1$条边, 因此, 树是最小连通的. 



## 度序列

设$S$为$n$个正整数组整的序列$d_1,d_2,...,d_n$, 其中, $d_1\geq d_2\geq...\geq d_n$, 且$d_1+d_2+\cdots+d_n=2(n-1)$, 则存在一个树, 其度序列为$S$.

>   证明思路:
>   数学归纳法, 主要采用删边加边的方式进行, 需要注意的是这里要删去的边以及结点要满足是叶子结点.



## 树的叶子数

对非平凡树$T$, 度为$i$的结点数记为$n_i$, 其叶子数满足



$$
n_1=2+n_3+2n_4+3n_5+\cdots=2+\sum_{i=3}^\infty(i-2)n_i.
$$



>   证明思路:
>   将树绘制成一棵有根树, 根节点为叶子结点(端节点), 先考虑任何一条从根节点到任一叶结点的一条路, 于是度为1的结点数目加上2. 对任何度大于2的结点, 其度减去2正好是该结点中多出来的边, 这样的边一定可以找到叶子结点,  所以只需考虑这样的结点对叶结点的贡献即可. 

# 二分图与最大匹配问题





# Hall匹配定理

该定理在组合方面有重要的应用, 但是这里主要采用图论的语言来叙述并证明. 
$$
\fbox{定理: 对于}
$$

# 算法与实现



## 二分图的判定

在此过程中, 用$a$和$b$表示相反的标号
1. 任取一结点, 标记为$a$
2. 所有与$a$邻接的结点标记为$b$
3. 对任意已标记的结点$v$, 将所有与$v$邻接且未标记的结点标记为与$v$相反的标号. 
4. 重复步骤3, 直到不存在与已标记结点邻接且还未标记的结点. 
5. 如果图中还有未标记结点, 那么, 这些结点一定在一个新的连通分量中, 再选择其中一个结点标记为$a$, 转到步骤3.
6. 如果得到的图中, 所有邻接的结点都标记为不同的标号, 那么图$G$就是二分图. 设集合$V_1$为二分图中所有标记为$a$的结点集;集合$V_2$为二分图中所有标记为$b$的结点集. 如果存在一对邻接点标记为同样的标号, 那么图$G$就不是二分图. 

采用`Python`实现, 图的存储使用*邻接表*实现. 

```python
def isBipartite(graph) -> bool:
    """
    未染色: 0
    染红色: 1
    染绿色: -1
    """
    n = len(graph)
    color_vec = [0] * n

    def dfs(i, color):
        for it in graph[i]:
            if color_vec[it] == 0:
                # 如果未染色, 进行染色
                color_vec[it] = -color
                if not dfs(it, -color):
                    # 染色后dfs判断
                    return False
            elif color_vec[it] == -color:
                # 满足条件进行下一轮遍历
                continue
            else:
                return False
        return True

    for i in range(n):
        if color_vec[i] == 0:
            # 说明存在新的连通分支, 进行dfs
            if not dfs(i, r):
                return False
    return True


if __name__ == '__main__':
    # 采用邻接表的方式存储图
    g1 = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]
    g2 = [[1], [2, 3], [4], [0, 4], [1]]
    g3 = [[1, 3], [0, 2], [1, 3], [0, 2]]
    print(isBipartite(g1))
    print(isBipartite(g2))
    print(isBipartite(g3))

```





## 寻找最小生成树

### Kruskal算法







### Prim算法(核心是广度优先算法)







