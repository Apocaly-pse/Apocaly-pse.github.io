---
tags: Mathematics
---



# 写在前面

最近刷LeetCode, 发现很多双百题解用到的都是位运算异或的技巧, 下面来总结一下位运算的常用技巧. 一开始参考了知乎的一篇回答, 里面推荐一本书叫做*算法心得*, 英文原版为*Hackers Delight*, 听这个名字就知道是一些hack技巧, 有机会一定要研读一下. 下文用的语言都是Python.



# 位运算操作符

这里以Python为例进行总结, 有的语言可能有一些区别, 例如JavaScript中的左移位还分为有符号和无符号的情况, 包括了三种移位操作. 

| 运算名称 | 符号 |           运算规则           |
| :------: | :--: | :--------------------------: |
|    与    | `&`  | `0&0=0  0&1=0  1&0=0  1&1=1` |
|    或    | `|`  | `0|0=0  0|1=1  1|0=1  1|1=1` |
|    非    | `~`  |         `~0=1 ~1=0`          |
|   异或   | `^`  | `0^0=0  0^1=1  1^0=1  1^1=0` |
|  左移位  | `<<` |       `0001<<1 = 0010`       |
|  右移位  | `>>` |       `1000>>1 = 0100`       |
|          |      |                              |



## 优先级

这里要注意一点, **位运算符的优先级要低于比较运算符**, 所以下面的位运算一定要带上括号, 否则会有意想不到的问题.



# 运算性质







# 判断奇偶

```python
isOdd = lambda n: n&1==1
```



# 指定位计数

对于一个二进制串`1011001`(89), 其中含有的`1`的个数有多少呢? 一个直观的思路当然是遍历取出, 直接模拟, 例如像下面这样:

```python
```

```js
x & (x - 1) //清除最右边的1
x & -x //得到最右边的1

```

# 判断2的幂(数的二进制表示是否仅有一位)

```python
(n&(n-1))==0
```

对于一个二进制数, 例如`10`, 其二进制表示为`1010`, `10-1=9`的二进制表示为`1001`, 两者做与运算得到`1000`即`=8!=0`, 但是对于`0100`(4), 其与`3`(`0011`)做与运算就是`0`, 这是因为对任意一个数`x`, 其减去`1`之后得到的二进制数需要从二进制表示的`从低位到高位`中最近的一个`1`借位, 使该借位的`1`后面的所有`0`都变成`1`, 那么如果这个数`x`仅有一个位`1`的话, 就可得出`x&x-1=0`了, 反之, 如果数`x`的二进制表示中不只有一个`1`, 那么减一操作只会借走最低位的`1`, 而其他剩下的`1`就不会变成`0`, 导致与运算之后结果不为`0`了.

而一个数字是不是`2`的幂, 只需要看其二进制表示中是不是只有一个位为`1`, 于是就可以通过`x&x-1==0`来判断了.



```python
(n&(-n))==n
```

同样地, 我们来分析

# 找不同(数或字符串)

通过异或的方法



# 找出某数的某一个二进制位

```python
# Python Version
# 获取 a 的第 b 位，最低位编号为 0
def getBit(a, b):
    return (a >> b) & 1
```





# 某一位设置为1

```python
# Python Version
# 将 a 的第 b 位设置为 1 ，最低位编号为 0
def setBit(a, b):
    return a | (1 << b)
```



# 用位运算模拟两数相加(异或)

[剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/);
