---
tags: LeetCode C++ DSA
---

# 写在前面

最近用到的异或运算越来越多了, 而其中又以只出现一次的数字为经典题型, 下面总结总结一下只出现一次的数字系列. 代码均为C++. 



# 前置知识

## 逻辑表达式

>   下面这些结论都可以自己写一个真值表推导得出. 

|          符号           |   运算   |                           性质                            |
| :---------------------: | :------: | :-------------------------------------------------------: |
|        $\bar\ $         |  逻辑非  |                             -                             |
| $\cdot$  (也可省略不写) |  逻辑与  | $xy=yx$, $x\cdot1=x$<br />$x\cdot x=x$, $x\cdot\bar x=0$, |
|           $+$           |  逻辑或  |     $x+y=y+x$, $x+\bar x=1$, <br />$x+x=x$, $x+1=1$,      |
|        $\oplus$         | 逻辑异或 |               $x\oplus y=x\bar y+\bar xy$,                |

一些之后会用到的二级结论有:

1.   $\overline{x\oplus y}=xy+\bar x\bar y$;
2.   德摩根律: $\overline{xy}=\bar x+\bar y$, $\overline {x+y}=\bar x\bar y$;
3.   

真值表转化为逻辑表达式



# 基本题型

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/);

直接异或即可, 最快的方法. 

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans{};
        for(int num:nums)ans^=num;
        return ans;
    }
};
```



# 异或的高级用法

## 异或分组

-   [260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/);
-   [剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/);

这两题是一样的, 都是通过位运算分组的方法来做. 

```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int xorsum{};
        for(auto num:nums)xorsum^=num;
        int lsb=xorsum==INT_MIN?xorsum:xorsum&(-xorsum);
        int type1{};
        for(int num:nums)
            if (lsb&num)
                type1^=num;
        return {type1, xorsum^type1};
    }
};
```



[面试题 17.19. 消失的两个数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-two-lcci/);





# 位运算的混合用法:逻辑表达式



[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/);

下面是接近`O(n)`的做法, 原因是采用了一个32位的逐位遍历. 

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans{};
        //32个位
        for (int i{};i<32;++i){
            int total{};
            for (int num:nums)
                total+=(num>>i)&1;
            if (total%3)
            ans|=(1<<i);
        }
        return ans;
    }
};
```

`O(n)`做法需要一定的逻辑表达式知识, 通过**真值表**得到**逻辑表达式**, 这里还应用了一个技巧, 就是直接通过现有的Y值更新X, 参考了题解[^2].

>   [逻辑电路角度详细分析该题思路，可推广至通解 - 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/);

下面我用题解中的思路重新走一遍推导过程, 加深一下理解. 



设当前状态为XYXY，输入为ZZ，那么我们可以分别为XX和YY列出真值表



| $XY$ | $Z$  | $X_n$ | $Y_n$ |
| :--: | :--: | :---: | :---: |
|  00  |  0   |   0   |   0   |
|  01  |  0   |   0   |   1   |
|  10  |  0   |   1   |   0   |
|  00  |  1   |   0   |   1   |
|  01  |  1   |   1   |   0   |
|  10  |  1   |   0   |   0   |







```cpp
```



或者更简洁的方法:

```cpp

```





# 位运算的特殊处理

[剑指 Offer II 070. 排序数组中只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/skFtm2/);
这道题虽然不是主要用位运算做, 但是其中蕴含的一个思想很经典, 就是用异或操作来忽略对数字奇偶性的讨论:

```cpp

```





# 最后的总结

1.   如果题目中说了排序数组, 那么大概率去想二分做法;
2.   只出现一次的两个数字, 通过异或lsb的方式进行分组;
3.   对于给出范围的题目(例如从1到N的正整数), 可以通过数学方法联立方程找出出现一次的数字;
4.   原地哈希也是不错的选择, 但是比较难想到.