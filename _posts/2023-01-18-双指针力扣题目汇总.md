---
tags: DSA LeetCode C++
---

# 基本题目



1.   [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/);(经典的双指针问题, 需要去重)

2.   [16. 最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/);

3.   [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/);

4.   [面试题 16.24. 数对和 - 力扣（LeetCode）](https://leetcode.cn/problems/pairs-with-sum-lcci/);

5.   [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/);(经典的双指针题, 原地算法)

6.   [80. 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/);(同样需要原地算法, 通解)

7.   [31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/);(涉及一个字典序算法)

8.   [1662. 检查两个字符串数组是否相等 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/);(虽然是简单题,但是用双指针需要考虑越界等问题)

9.   [1805. 字符串中不同整数的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-different-integers-in-a-string/);(可暴力)

10.   

11.   [1750. 删除字符串两端相同字符后的最短长度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/);(常规双指针, 注意循环跳出的条件)

12.   [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/);(原地算法, 比较经典的一类应用)

13.   [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/);(也可以DP, 但是双指针速度快)

      ```cpp
      class Solution {
      public:
          bool isSubsequence(string s, string t) {
              int ns = s.size(), nt = t.size();
              int i{}, j{};
              while (i < ns && j < nt) {
                  while (i < ns && j < nt && s[i] == t[j]) ++i, ++j;
                  ++j;
              }
              return i == ns;
          }
      };
      ```

      

14.   [38. 外观数列 - 力扣（LeetCode）](https://leetcode.cn/problems/count-and-say/);(经典双指针应用)

15.   [904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/);

16.   [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/);

---

# 同向双指针

>   方法:
>
>   1.   遍历右边界
>   2.   添加元素
>   3.   删除元素
>   4.   判断满足条件, 更新ans



1.   [6270. 每种字符至少取 K 个 - 力扣（LeetCode）](https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/);(需要处理两段, 不太好想)
2.   [1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/);
3.   [3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/);
4.   [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/);
5.   [713. 乘积小于 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-product-less-than-k/);



# 相向双指针

1.   [647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/);(中心扩展算法)

     ```cpp
     class Solution {
     public:
         int countSubstrings(string s) {
             int n = s.size(), ans{};
             for (int i{}; i < n; ++i)
                 for (int j{}; j < 2; ++j) {
                     int l = i, r = i + j;
                     while (l >= 0 && r < n && s[l--] == s[r++]) ans++;
                 }
             return ans;
         }
     };
     ```
     
     
     
1.   [1813. 句子相似性 III - 力扣（LeetCode）](https://leetcode.cn/problems/sentence-similarity-iii/);

     ```cpp
     class Solution {
     public:
         bool areSentencesSimilar(string sentence1, string sentence2) {
             if (sentence1 == sentence2) return true;
             int n1 = sentence1.size(), n2 = sentence2.size();
             if (n1 < n2) swap(sentence1, sentence2), swap(n1, n2);
             int p1{};
             while (p1 < n2)
                 if (sentence1[p1] == sentence2[p1]) {
                     p1++;
                     continue;
                 } else
                     break;
             if (p1 == n2 && sentence1[p1] == ' ') return true;
             int q1{n1 - 1}, q2{n2 - 1};
             while (q2 >= 0)
                 if (sentence1[q1] == sentence2[q2]) {
                     q1--, q2--;
                     continue;
                 } else
                     break;
             if (q2 == -1 && sentence1[q1] == ' ') return true;
             return p1 > q2 && sentence2[q2 + 1] == ' ' && sentence1[q2 + 1] == ' ';
         }
     };
     ```

     



# 螺旋矩阵系列

螺旋矩阵系列, 其实严格来说不算双指针, 但是其中蕴含的思想很像双指针. (应该叫四指针)

1.   [54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/);(需要四个指针分别在需要转弯的时候移动)
2.   [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/);(跟上面的题异曲同工)
3.   [885. 螺旋矩阵 III - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-iii/);(不需要考虑边界直接模拟, 注意这个题是从内往外转, 需要定义方向数组)
4.   [2326. 螺旋矩阵 IV - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-iv/);(同基本的螺旋矩阵, 加上链表向后遍历的基本操作即可)

## 螺旋矩阵I

只能说, 用Python不讲武德:

```python
def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
    res = []
    while matrix:
        # 削头（第一层）
        res += matrix.pop(0)
        # 将剩下的逆时针转九十度，等待下次被削
        matrix = list(zip(*matrix))[::-1]
    return res
```







# 快慢指针

快慢指针(链表中常用这种算法)

1.   [287. 寻找重复数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-duplicate-number/);(用到了判圈算法)

     ```cpp
     class Solution {
     public:
         int findDuplicate(vector<int>& nums) {
             int f{},s{};
             do f=nums[nums[f]],s=nums[s];
             while (f!=s);
             f=0;
             while(f!=s)f=nums[f],s=nums[s];
             return s;
         }
     };
     ```





 

## 80.删除有序数组重复项II

可以通过快慢指针做, 如下:

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if (n:=len(nums))<3:return n 
        p1,p2=1,2
        while p2<n:
            if nums[p1-1]!=nums[p2]:
                p1+=1
                nums[p1]=nums[p2]
            p2+=1
        return p1+1
```

下面是宫水三叶提供的通解[^1].

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        def process(k):
            idx=0
            for num in nums:
                if idx<k or nums[idx-k]!=num:
                    nums[idx]=num
                    idx+=1
            return idx
        return process(2)
```

其实快慢指针也可以给出通解, 只不过需要修改的参数比较多:(看起来比较复杂)

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        def process(k):
            if (n:=len(nums))<k+1:return n 
            p1,p2=k-1,k
            while p2<n:
                if nums[p1-k+1]!=nums[p2]:
                    p1+=1
                    nums[p1]=nums[p2]
                p2+=1
            return p1+1
        return process(2)
```







# 滑动窗口

滑动窗口系列, 其实本质上还是双指针, 通过左右的两个指针来划定滑动窗口的范围, 然后进行操作. (本质上还是双指针, 只不过两根指针之间的窗口大小不变)

1.   [3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/);
2.   



# ref

[^1]:[【宫水三叶】关于「删除有序数组重复项」的通解 - 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/gong-shui-san-xie-guan-yu-shan-chu-you-x-glnq/);