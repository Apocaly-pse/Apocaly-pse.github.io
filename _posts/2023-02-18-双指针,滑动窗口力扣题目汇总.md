---
tags: DSA LeetCode C++ Python
---

# 可能用到的STL算法一览



## 前缀和计算: `partial_sum`

使用方法: 

>   [std::partial_sum - cppreference.com](https://zh.cppreference.com/w/cpp/algorithm/partial_sum);

```cpp
#include <numeric>
#include <vector>
#include <iostream>
#include <iterator>
#include <functional>
void t1() {
    std::vector<int> v = {2, 2, 2, 2, 2,
                          2, 2, 2, 2, 2}; // 或 std::vector<int>v(10, 2);

    std::cout << "前 10 个偶数是：";
    std::partial_sum(v.begin(), v.end(),
                     std::ostream_iterator<int>(std::cout, " "));
    std::cout << '\n';

    std::partial_sum(v.begin(), v.end(), v.begin(), std::multiplies<int>());

    std::cout << "2 的前 10 个幂是：";
    for (auto n : v) std::cout << n << " ";
    std::cout << '\n';
}


void t2() {
    using namespace std;
    vector<int> v{1, 2, 3, 4, 5};
    vector<int> ans(v.size() + 1);
    struct f {
        constexpr int operator()(const int& lhs, const int& rhs) {
            return lhs + rhs;
        }
    };
    // partial_sum(v.begin(), v.end(), ans.begin() + 1, plus<int>());
    // partial_sum(v.begin(), v.end(), ans.begin() + 1, f());
    partial_sum(v.begin(), v.end(), ans.begin() + 1,
                [](const int& lhs, const int& rhs) { return lhs + rhs; });
    for (auto i : ans) cout << i << " ";
    cout << endl;
}

int main() {
    // t1();
    t2();
    return 0;
}
```





## 二分下界: `lower_bound`









# 基本题目



1.   [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/);(经典的双指针问题, 需要去重)

2.   [16. 最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/);

3.   [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/);

4.   [面试题 16.24. 数对和 - 力扣（LeetCode）](https://leetcode.cn/problems/pairs-with-sum-lcci/);

5.   [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/);

     ```cpp
     class Solution {
     public:
         int removeElement(vector<int>& nums, int val) {
             int n = nums.size(), l{};
             for (int r{}; r < n; ++r) {
                 if (nums[r] != val) 
                     nums[l++] = nums[r];
             }
             return l;
         }
     };
     ```

     

6.   [31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/);(涉及一个字典序算法)

7.   [1662. 检查两个字符串数组是否相等 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/);(虽然是简单题,但是用双指针需要考虑越界等问题)

8.   [1805. 字符串中不同整数的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-different-integers-in-a-string/);(可暴力)

9.   [1750. 删除字符串两端相同字符后的最短长度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/);(常规双指针, 注意循环跳出的条件)

10.   [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/);(原地算法, 比较经典的一类应用)

      ```cpp
      ```

      

11.   [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/);(也可以DP, 但是双指针速度快)

      ```cpp
      class Solution {
      public:
          bool isSubsequence(string s, string t) {
              int ns = s.size(), nt = t.size();
              int i{}, j{};
              while (i < ns && j < nt) {
                  while (i < ns && j < nt && s[i] == t[j]) ++i, ++j;
                  ++j;
              }
              return i == ns;
          }
      };
      ```

      

12.   [38. 外观数列 - 力扣（LeetCode）](https://leetcode.cn/problems/count-and-say/);(经典双指针应用)

13.   [904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/);

14.   [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/);

---

# 同向双指针(滑动窗口)

滑动窗口系列, 其实本质上还是双指针, 通过左右的两个指针来划定滑动窗口的范围, 然后进行操作. (本质上还是双指针, 只不过两根指针之间的窗口大小不变)

>   方法:
>
>   1.   遍历右边界
>   2.   添加元素
>   3.   删除元素
>   4.   判断满足条件, 更新ans



1.   [6270. 每种字符至少取 K 个 - 力扣（LeetCode）](https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/);(需要处理两段, 不太好想)

2.   [1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/);

3.   [219. 存在重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/contains-duplicate-ii/);(哈希映射map也可以做, 不过内存占用大)

     ```cpp
     class Solution {
     public:
         bool containsNearbyDuplicate(vector<int>& nums, int k) {
             unordered_set<int> win{};
             for (int i{}; i < nums.size(); ++i) {
                 if (i > k) win.erase(nums[i - k - 1]);
                 if (win.find(nums[i]) != win.end()) return true;
                 win.emplace(nums[i]);
             }
             return false;
         }
     };
     ```

4.   [3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/);

     ```cpp
     class Solution {
     public:
         int lengthOfLongestSubstring(string s) {
             unordered_set<char> win{};
             int left{}, ans{};
             for (auto c : s) {
                 while (win.find(c) != win.end()) win.erase(s[left++]);
                 win.insert(c);
                 ans = max(ans, (int)win.size());
             }
             return ans;
         }
     };
     ```

     只用STL来做, 比较慢(主要慢在遍历`size()`上), 下面改进一下, 用下标索引计算来更新`ans`.

     ```cpp
     class Solution {
     public:
         int lengthOfLongestSubstring(string s) {
             unordered_set<char> win{};
             int left{}, ans{};
             for (int i{}; i < s.size(); ++i) {
                 while (win.find(s[i]) != win.end()) win.erase(s[left++]);
                 win.insert(s[i]);
                 ans = max(ans, i - left + 1);
             }
             return ans;
         }
     };
     ```

     还不够快, 使用C-style数组代替哈希集合. 这里数组初始化用到了C++11的initializer_list, 比`memset`来的方便. 

     ```cpp
     class Solution {
     public:
         int lengthOfLongestSubstring(string s) {
             int win[128]{};
             int left{}, ans{};
             for (int i{}; i < s.size(); ++i) {
                 while (win[s[i]]) win[s[left++]] = 0;
                 win[s[i]] = 1;
                 ans = max(ans, i - left + 1);
             }
             return ans;
         }
     };
     ```

5.   [1234. 替换子串得到平衡字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/);

     两根指针指向窗口的左右边界. 
     ```cpp
     class Solution {
     public:
         int balancedString(string s) {
             int n = s.size(), m = n / 4, cnt[4]{};
             string t = "QWER";
             for (char c : s) ++cnt[t.find(c)];
             if (cnt[0] == m && cnt[1] == m && cnt[2] == m && cnt[3] == m)
                 return 0;
             int ans = n;
             for (int r{}, l{}; r < n; ++r) {
                 --cnt[t.find(s[r])];
                 while (l <= r && cnt[0] <= m && cnt[1] <= m && cnt[2] <= m && cnt[3] <= m)
                     ans = min(ans, r - l + 1), ++cnt[t.find(s[l++])];
             }
             return ans;
         }
     };
     ```

     这里用到了一个不错的减少内存占用的方法, 就是把`QWER`四个字母计数映射到一个4元素的数组中, 通过`find()`方法实现. 

6.   [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/);
     不错的题目, 有很多方法(当然最快的就是滑窗), 分别记录如下:

     -   暴力遍历(时间$n^2$空间$1$)
     -   前缀和+二分(时间$n\log n$空间$n$)
     -   滑窗(时间$n$空间$1$)

     ```cpp
     // 暴力: 能过就行(更新测试数据集之后连C++都过不了了)
     class Solution {
     public:
         int minSubArrayLen(int target, vector<int>& nums) {
             int n = nums.size(), ans = INT_MAX;
             for (int l{}; l < n; ++l) {
                 int win_len{}, win_sum{};
                 for (int r{l}; r < n; ++r) {
                     ++win_len, win_sum += nums[r];
                     if (win_sum >= target) {
                         ans = min(win_len, ans);
                         break;
                     }
                 }
             }
             return ans == INT_MAX ? 0 : ans;
         }
     };
     ```

     前缀和+二分:
     ```cpp
     class Solution {
     public:
         int minSubArrayLen(int target, vector<int>& nums) {
             int n = nums.size(), ans = INT_MAX;
             vector<int> sums(n + 1);
             partial_sum(nums.begin(), nums.end(), sums.begin() + 1, plus<int>());
             for (int i{1}; i <= n; ++i) {
                 auto it = lower_bound(sums.begin(), sums.end(), target + sums[i - 1]);
                 if (it != sums.end())
                     ans = min(ans, static_cast<int>(it - sums.begin() - (i - 1)));
             }
             return ans == INT_MAX ? 0 : ans;
         }
     };
     ```

     >因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。
     >
     >作者：LeetCode-Solution

     滑窗:

     ```cpp
     class Solution {
     public:
         int minSubArrayLen(int target, vector<int>& nums) {
             int n = nums.size(), ans = n + 1;
             int l{}, win_sum{};
             for (int r{}; r < n; ++r) {
                 win_sum += nums[r];
                 while (win_sum >= target)
                     ans = min(r - l + 1, ans), win_sum -= nums[l++];
             }
             return ans == n + 1 ? 0 : ans;
         }
     };
     ```

     

7.   [713. 乘积小于 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-product-less-than-k/);

     ```cpp
     class Solution {
     public:
         int numSubarrayProductLessThanK(vector<int>& nums, int k) {
             if (k <= 1) return 0;
             int n = nums.size(), ans{}, l{}, prod{1};
             for (int r{}; r < n; ++r) {
                 prod *= nums[r];
                 while (prod >= k) 
                     prod /= nums[l++];
                 ans += r - l + 1;
             }
             return ans;
         }
     };
     ```

8.   [438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/);

9.   [30. 串联所有单词的子串 - 力扣（LeetCode）](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/);(上一题的进阶版)

10.   



# 相向双指针

1.   [647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/);(中心扩展算法)

     ```cpp
     class Solution {
     public:
         int countSubstrings(string s) {
             int n = s.size(), ans{};
             for (int i{}; i < n; ++i)
                 for (int j{}; j < 2; ++j) {
                     int l = i, r = i + j;
                     while (l >= 0 && r < n && s[l--] == s[r++]) ans++;
                 }
             return ans;
         }
     };
     ```
     
     
     
1.   [1813. 句子相似性 III - 力扣（LeetCode）](https://leetcode.cn/problems/sentence-similarity-iii/);

     ```cpp
     class Solution {
     public:
         bool areSentencesSimilar(string sentence1, string sentence2) {
             if (sentence1 == sentence2) return true;
             int n1 = sentence1.size(), n2 = sentence2.size();
             if (n1 < n2) swap(sentence1, sentence2), swap(n1, n2);
             int p1{};
             while (p1 < n2)
                 if (sentence1[p1] == sentence2[p1]) {
                     p1++;
                     continue;
                 } else
                     break;
             if (p1 == n2 && sentence1[p1] == ' ') return true;
             int q1{n1 - 1}, q2{n2 - 1};
             while (q2 >= 0)
                 if (sentence1[q1] == sentence2[q2]) {
                     q1--, q2--;
                     continue;
                 } else
                     break;
             if (q2 == -1 && sentence1[q1] == ' ') return true;
             return p1 > q2 && sentence2[q2 + 1] == ' ' && sentence1[q2 + 1] == ' ';
         }
     };
     ```

     



# 螺旋矩阵系列

螺旋矩阵系列, 其实严格来说不算双指针, 但是其中蕴含的思想很像双指针. (应该叫四指针)

1.   [54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/);(需要四个指针分别在需要转弯的时候移动)
2.   [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/);(跟上面的题异曲同工)
3.   [885. 螺旋矩阵 III - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-iii/);(不需要考虑边界直接模拟, 注意这个题是从内往外转, 需要定义方向数组)
4.   [2326. 螺旋矩阵 IV - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-iv/);(同基本的螺旋矩阵, 加上链表向后遍历的基本操作即可)

## 螺旋矩阵I

只能说, 用Python不讲武德:

```python
def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
    res = []
    while matrix:
        # 削头（第一层）
        res += matrix.pop(0)
        # 将剩下的逆时针转九十度，等待下次被削
        matrix = list(zip(*matrix))[::-1]
    return res
```

但是C++的写法也很简练, 思路直接在代码中体现出来了. 

```cpp
```

或者用一种定义方向数组的写法, 算是一种模板了. 

```cpp
```







# 快慢指针

快慢指针(链表中常用这种算法)



## 寻找重复数

[287. 寻找重复数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-duplicate-number/);(用到了判圈算法)

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int f{}, s{};
        do f = nums[nums[f]], s = nums[s];
        while (f != s);
        f = 0;
        while (f != s) f = nums[f], s = nums[s];
        return s;
    }
};
```



 

## 删除重复项

需要用到原地修改方法, 多练就掌握了. 下面给出Python和C++两种实现, 包括一种通解的写法. 

### 26.删除有序数组重复项

[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/);(经典的双指针题, 原地算法)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size(); 
        if (n < 2) return n;
        int l{}, r{1};
        while (r < n) {
            if (nums[l] != nums[r])
                nums[++l] = nums[r];
            ++r;
        }
        return 1 + l;
    }
};
```



### 80.删除有序数组重复项II

[80. 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/);

可以通过快慢指针做, 个人感觉比较直观. 左指针指向重复的第一个数字, 右指针指向要删除的部分, 用右指针(重复之后出现的不同的数字)不断更新左指针的后一个位置即可. 代码如下:

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if (n := len(nums)) < 3:
            return n
        p1, p2 = 1, 2
        while p2 < n:
            if nums[p1 - 1] != nums[p2]:
                p1 += 1
                nums[p1] = nums[p2]
            p2 += 1
        return p1 + 1
```

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) return n;
        int l{1}, r{2};
        while (r < n) {
            if (nums[l - 1] != nums[r])
                nums[++l] = nums[r];
            ++r;
        }
        return 1 + l;
    }
};
```



下面是宫水三叶提供的通解. 

>   [【宫水三叶】关于「删除有序数组重复项」的通解 - 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/gong-shui-san-xie-guan-yu-shan-chu-you-x-glnq/);

针对删除超过重复次数为`k`的数字的通解. 

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        def process(k):
            idx = 0
            for num in nums:
                if idx < k or nums[idx - k] != num:
                    nums[idx] = num
                    idx += 1
            return idx
        return process(2)
```

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        auto f = [&](int k) {
            int idx{};
            for (int num: nums)
                if (idx < k || nums[idx - k] != num)
                    nums[idx++] = num;
            return idx;
        };
        return f(2);
    }
};
```



其实快慢指针也可以给出通解, 只不过**需要修改的参数比较多**:(看起来比较复杂)

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        def process(k):
            if (n := len(nums)) < k + 1:
                return n
            p1, p2 = k - 1, k
            while p2 < n:
                if nums[p1 - k + 1] != nums[p2]:
                    p1 += 1
                    nums[p1] = nums[p2]
                p2 += 1
            return p1 + 1
        return process(2)
```

C++版:

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        auto f = [&](int k) {
            int n = nums.size();
            if (n < k + 1)
                return n;
            int l{k - 1}, r{k};
            while (r < n) {
                if (nums[l - k + 1] != nums[r])
                    nums[++l] = nums[r];
                ++r;
            }
            return 1 + l;
        };
        return f(2);
    }
};
```

