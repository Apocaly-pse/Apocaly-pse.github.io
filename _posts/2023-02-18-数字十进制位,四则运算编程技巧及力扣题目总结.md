---
tags: DSA LeetCode C++ Python
---

# 写在前面

最近力扣周赛出了很多关于数字位数的题, 顾名思义, 就是对一个大整数的每一个十进制位进行操作, 由于之前对这方面的内容不太熟悉, 真正写的时候就吃亏了. 下面写一下这方面的常用的一些技巧, 例如取出任意整数的每一位等等.



# 取出整数的每一位

通过对`10`取余或者整除, 可以从个位到最高位依次得到每一个位的值, 如下:

```python
n = 12345
ans = []
while n:
    ans.append(n % 10)
    n //= 10
print(ans)
# [5, 4, 3, 2, 1]
```

上面的是数学方法, 速度比较快, 下面是一个基于字符串的方法, 虽然慢但是直观(我初刷lc时候钟爱这种方法)

```python
n = 12345
s = str(n)
ans = [int(c) for c in s]
print(ans)
# [1, 2, 3, 4, 5]
```

这种技巧虽然方便, 但是在遇到要对每一位进行加减等操作的时候, 还是比较麻烦的, 因为要考虑进位借位的情况.



# 从各个位组成的数组(字符串)中还原整数

这个技巧是上面的技巧的逆操作, 比较直观, 直接取第$i$位然后乘以$10^i$之后相加即可.(这里用的下标为`n-1-i`是为了从低位到高位开始还原)

```python
s = '12345'
ans = 0
for i in range(n := len(s)):
    ans += int(s[n - 1 - i]) * 10**i
print(ans, type(ans))
# 12345 <class 'int'>
```

当然不止这一种方法, 还有一种**正向**(高位到低位)遍历的方法:

```python
s = '12345'
ans = 0
for c in s:
    ans = int(c) + ans * 10
print(ans, type(ans))
# 12345 <class 'int'>
```

这里比较推荐第二种, 因为很多字符串遍历用的都是正序. 



## LC-8: 字符串转整数

```cpp
class Solution {
public:
    int strToInt(string str) {
        string num{};
        bool flg{};
        for (auto c: str) {
            if (flg && !isdigit(c)) break;
            if (c == ' ') continue;
            if (c != '-' && c != '+' && !isdigit(c) && !flg) return 0;
            flg = true, num += c;
        }
        long long ans{};
        if (num == "") return 0;
        flg = false;
        for (int i{}; i < num.size(); ++i)
            if (num[i] == '-') flg = true;
            else if (num[i] == '+') flg = false;
            else {
                if (!flg && ans > INT_MAX) return INT_MAX;
                else if (flg && ans > INT_MAX) return INT_MIN;
                ans = ans * 10 + (num[i] - '0');
            }
        ans = (flg) ? -ans : ans;
        if (ans > INT_MAX) return INT_MAX;
        else if (ans < INT_MIN) return INT_MIN;
        return ans;
    }
};
```



# 反转每一个十进制位

这里的题型需要综合上面的两个技巧, 总体来看并不难.

[7. 整数反转 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-integer/);(上面两种方法均可)

```python
class Solution:
    def reverse(self, x: int) -> int:
        tmp = []
        neg = False
        if x == 0:
            return x
        if x < 0:
            x = -x
            neg = True
        while x:
            tmp.append(x % 10)
            x //= 10
        dig = 0
        for i in tmp:
            dig = dig * 10 + i
        if neg:
            dig = -dig
        return dig if -2**31 <= dig <= 2**31 - 1 else 0
```

C++版(原地反转, 空间复杂度$O(1)$)

```cpp
class Solution {
public:
    int reverse(int x) {
        long i{}, ans{}, num = x;
        bool neg = false;
        if (num < 0) num = -num, neg = true;
        while (num) i = num % 10, ans = 10l * ans + i, num /= 10;
        ans = neg ? -ans : ans;
        return ans > INT_MAX || ans < INT_MIN ? 0 : ans;
    }
};
```

采用数学做法会快一些, 而字符串相对简洁一些. 

# 各位求和

[258. 各位相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-digits/);(可以模拟做, 不过有更简便的取余方法)

>   需要了解一个结论, 任何数的各位数相加之后只取个位数的话所得到的值一定是这个数对`9`取余得到的余数. 

并且对于C++和Python, 两者的取余运算符含义并不相同, 比较如下:

-   C++
-   Python

所以, 针对上述结论, 两种语言的实现方法不一样:

```python
```



# 逐位加法

[415. 字符串相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-strings/);(两数从低位到高位逐位相加, 模拟竖式计算, 需要注意进位补零)



# 逐位乘法

[43. 字符串相乘 - 力扣（LeetCode）](https://leetcode.cn/problems/multiply-strings/);(需要用到乘法竖式计算的模拟);



# 快速乘法

这里算是插一个题外话了, 但是不得不提, 因为下面的除法就要用了(限定不能使用乘法运算符). 思路就是下面的快速幂算法, 迭代思路需要点技巧. 

```cpp
int mul(int a, int b) {
    int ans{};
    bool sgn = (a > 0) ^ (b > 0);
    if (a < 0) a = -a;
    if (b < 0) b = -b;
    while (b) {
        if (b & 1) ans += a;
        a += a;
        b >>= 1;
    }
    return sgn ? -ans : ans;
}
```



# 逐位除法

[29. 两数相除 - 力扣（LeetCode）](https://leetcode.cn/problems/divide-two-integers/);

竖式除法模拟:

```cpp
```



二分查找简单一些, 如下:(后来发现不满足题意说的不能使用`long`和乘法)

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        bool flg1{}, flg2{};
        long dvd = dividend, dvs = divisor;
        if (dvd < 0) dvd = -dvd, flg1 = true;
        if (dvs < 0) dvs = -dvs, flg2 = true;

        long l{}, r = dvd, mid{};
        while (l <= r) {
            mid = (l + r) >> 1;
            if (dvs * mid <= dvd)
                l = mid + 1;
            else
                r = mid - 1;
        }
        long ans = (flg1 != flg2 ? 1 - l : l - 1);
        return ans > INT32_MAX || ans < INT32_MIN ? INT32_MAX : ans;
    }
};
```

# 快速幂

```cpp
class Solution {
public:
    double f(double x, long n) {
        if (n == 0) return 1;
        double y = f(x, n / 2);
        return n % 2 ? y * x * y : y * y;
    }
    double myPow(double x, int n) {
        if (n == 1) return x;
        if (x == 1.0) return 1;
        long m = 1l * n;
        return m > 0 ? f(x, m) : 1 / f(x, -m);
    }
};
```

经典的迭代法(二进制表示计入贡献): 

```cpp
class Solution {
public:
    double f(double x, long n) {
        double ans = 1.0, y = x;
        while (n) {
            if (n & 1) ans *= y;
            y *= y;
            n >>= 1;
        }
        return ans;
    }
    double myPow(double x, int n) {
        long m = n;
        return m > 0 ? f(x, m) : 1 / f(x, -m);
    }
};
```

