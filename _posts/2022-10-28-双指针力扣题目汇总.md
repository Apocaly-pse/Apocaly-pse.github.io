---
tags: LeetCode C/C++
---

# 题目列表



1.   [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/);(经典的双指针问题, 需要去重)
2.   [16. 最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/);
3.   [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/);
4.   [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/);(经典的双指针题, 原地算法)
5.   [80. 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/);(同样需要原地算法, 通解)
6.   [31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/);(涉及一个字典序算法)
7.   [1662. 检查两个字符串数组是否相等 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/);(虽然是简单题,但是用双指针需要考虑越界等问题)
8.   [1805. 字符串中不同整数的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-different-integers-in-a-string/);(可暴力)
9.   [6270. 每种字符至少取 K 个 - 力扣（LeetCode）](https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/);(需要处理两段, 不太好想)
10.   [1750. 删除字符串两端相同字符后的最短长度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/);(常规双指针, 注意循环跳出的条件)
11.   [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/);(原地算法, 比较经典的一类应用)
12.   [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/);(也可以DP, 但是双指针速度快)
13.   [38. 外观数列 - 力扣（LeetCode）](https://leetcode.cn/problems/count-and-say/);(经典双指针应用)

---

螺旋矩阵系列, 其实严格来说不算双指针, 但是其中蕴含的思想很像双指针. (应该叫四指针)

1.   [54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/);
2.   [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/);
3.   [885. 螺旋矩阵 III - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-iii/);(不需要考虑边界直接模拟)
4.   [2326. 螺旋矩阵 IV - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-iv/);

---

滑动窗口系列, 其实本质上还是双指针, 通过左右的两个指针来划定滑动窗口的范围, 然后进行操作.

# 思路与代码

外面`while`循环, 然后里面加上指针移动. 



 

## 80.删除有序数组重复项II

可以通过快慢指针做, 如下:

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if (n:=len(nums))<3:return n 
        p1,p2=1,2
        while p2<n:
            if nums[p1-1]!=nums[p2]:
                p1+=1
                nums[p1]=nums[p2]
            p2+=1
        return p1+1
```

下面是宫水三叶提供的通解[^1].

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        def process(k):
            idx=0
            for num in nums:
                if idx<k or nums[idx-k]!=num:
                    nums[idx]=num
                    idx+=1
            return idx
        return process(2)
```

其实快慢指针也可以给出通解, 只不过需要修改的参数比较多:(看起来比较复杂)

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        def process(k):
            if (n:=len(nums))<k+1:return n 
            p1,p2=k-1,k
            while p2<n:
                if nums[p1-k+1]!=nums[p2]:
                    p1+=1
                    nums[p1]=nums[p2]
                p2+=1
            return p1+1
        return process(2)
```





## 螺旋矩阵I

只能说, 用Python不讲武德:

```python
def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
    res = []
    while matrix:
        # 削头（第一层）
        res += matrix.pop(0)
        # 将剩下的逆时针转九十度，等待下次被削
        matrix = list(zip(*matrix))[::-1]
    return res
```







# ref

[^1]:[【宫水三叶】关于「删除有序数组重复项」的通解 - 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/gong-shui-san-xie-guan-yu-shan-chu-you-x-glnq/);